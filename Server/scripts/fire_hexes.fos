
#include "_macros.fos"
#include "_colors.fos"

#define MAX_STEP               ( 3 )
#define MAX_NAPALM_STEP		   ( 1 )
#define MAX_NAPALM_BALL_STEP   ( 2 )
#define NAPALM_FIRE_TIME	   ( (REAL_SECOND(5)) )
#define RND                    # ( v1, v2 )( Random( v1, v2 ) == 1 )
#define BURN_DAMAGE			   ( Random(30,50) )
#define FIRE_STEP_ON		   ( Random(30,50) )

import void InjureCritter( Critter& cr, uint dmg, uint dmgType, uint8 dir, uint attackerId ) from "combat";
import void AffectBurn(Critter& cr, int value) from "combat";
//import uint cte_Burn(Critter& cr, int identifier, uint& rate) from "combat";
//import uint GetBurnDuration(Critter& cr) from "combat";
//import void ApplyDamage(AttackStruct &attack, Critter &target, uint rounds, bool isCritical, bool intentionally, CombatRes[]& results) from "combat";

void MolotovBlast( Map& map, uint16 hexX, uint16 hexY, uint16 firePid, uint ownerId )
{
    uint[] values = { map.Id, hexX, hexY, 0, firePid, ownerId };
    CreateTimeEvent( __FullSecond, "e_MolotovBlast", values, false );
	map.PlaySound( "molotov.wav", hexX, hexY, 25 );
}

void NapalmBlast( Map& map, uint16 hexX, uint16 hexY, uint16 firePid, uint ownerId )
{
    uint[] values = { map.Id, hexX, hexY, 0, firePid, ownerId };
    CreateTimeEvent( __FullSecond, "e_NapalmBlast", values, false );
}

void NapalmBall( Map& map, uint16 hexX, uint16 hexY, uint16 firePid, uint ownerId )
{
    uint[] values = { map.Id, hexX, hexY, 0, firePid, ownerId };
    CreateTimeEvent( __FullSecond, "e_NapalmBall", values, false );
}

uint e_MolotovBlast( uint[] @ values )
{
    Map@   map = GetMap( values[ 0 ] );
    uint16 hexX = values[ 1 ];
    uint16 hexY = values[ 2 ];
    uint8  step = values[ 3 ];
    uint16 pid = values[ 4 ];
    uint   ownerId = values[ 5 ];
    uint   penaltyLowSkill = 0;
    if( step > ( MAX_STEP - penaltyLowSkill ) )
        return 0;
    uint[] fireIds;
	
    AddFire( map, hexX, hexY, ( step == 0 || ( step < 2 && RND( 1, 2 ) ) ), pid, ownerId, fireIds );

    for( uint curStep = 1; curStep < step; curStep++ )
    {
        hexX = values[ 1 ];
        hexY = values[ 2 ];
        map.MoveHexByDir( hexX, hexY, 4, curStep );
        for( uint i = 0; i < 6; i++ )
        {
            for( uint j = 0; j < curStep; j++ )
            {
                map.MoveHexByDir( hexX, hexY, i, 1 );
                AddFire( map, hexX, hexY, ( curStep + 2 > step ) || ( ( curStep + 3 > step ) && RND( 1, 2 ) ) || RND( 1, 3 ), pid, ownerId, fireIds );
            }
        }
    }
    if( fireIds.length() > 0 )
        CreateTimeEvent( __FullSecond + uint( REAL_SECOND( Random( 4, 6 ) ) * ( 12 - step ) * ( 5 - penaltyLowSkill ) / 5 ), "e_DeleteFire", fireIds, true );
    values[ 3 ]++;
    return 2;
}

uint e_NapalmBlast( uint[] @ values )
{
    Map@   map = GetMap( values[ 0 ] );
    uint16 hexX = values[ 1 ];
    uint16 hexY = values[ 2 ];
    uint8  step = values[ 3 ];
    uint16 pid = values[ 4 ];
    uint   ownerId = values[ 5 ];
    uint   penaltyLowSkill = 0;
    if( step > ( MAX_NAPALM_STEP - penaltyLowSkill ) )
        return 0;
    uint[] fireIds;
    AddFire( map, hexX, hexY, ( step == 0 || ( step < 2 && RND( 1, 2 ) ) ), pid, ownerId, fireIds );

    for( uint curStep = 1; curStep < step; curStep++ )
    {
        hexX = values[ 1 ];
        hexY = values[ 2 ];
        map.MoveHexByDir( hexX, hexY, 4, curStep );
        for( uint i = 0; i < 6; i++ )
        {
            for( uint j = 0; j < curStep; j++ )
            {
                map.MoveHexByDir( hexX, hexY, i, 1 );
                AddFire( map, hexX, hexY, ( curStep + 2 > step ) || ( ( curStep + 3 > step ) && RND( 1, 2 ) ) || RND( 1, 3 ), pid, ownerId, fireIds );
            }
        }
    }
    if( fireIds.length() > 0 )
        CreateTimeEvent( __FullSecond + NAPALM_FIRE_TIME, "e_DeleteFire", fireIds, true );
    values[ 3 ]++;
    return 2;
}

uint e_NapalmBall( uint[] @ values )
{
    Map@   map = GetMap( values[ 0 ] );
    uint16 hexX = values[ 1 ];
    uint16 hexY = values[ 2 ];
    uint8  step = values[ 3 ];
    uint16 pid = values[ 4 ];
    uint   ownerId = values[ 5 ];
    uint   penaltyLowSkill = 0;
    if( step > ( MAX_NAPALM_BALL_STEP - penaltyLowSkill ) )
        return 0;
    uint[] fireIds;
    AddFire( map, hexX, hexY, ( step == 0 || ( step < 2 && RND( 1, 2 ) ) ), pid, ownerId, fireIds );

    for( uint curStep = 1; curStep < step; curStep++ )
    {
        hexX = values[ 1 ];
        hexY = values[ 2 ];
        map.MoveHexByDir( hexX, hexY, 4, curStep );
        for( uint i = 0; i < 6; i++ )
        {
            for( uint j = 0; j < curStep; j++ )
            {
                map.MoveHexByDir( hexX, hexY, i, 1 );
                AddFire( map, hexX, hexY, ( curStep + 2 > step ) || ( ( curStep + 3 > step ) && RND( 1, 2 ) ) || RND( 1, 3 ), pid, ownerId, fireIds );
            }
        }
    }
    if( fireIds.length() > 0 )
        CreateTimeEvent( __FullSecond + NAPALM_FIRE_TIME, "e_DeleteFire", fireIds, true );
    values[ 3 ]++;
    return 2;
}

uint e_DeleteFire( uint[] @ values )
{
    for( uint i = 0, l = values.length(); i < l; i++ )
    {
        if( values[ i ] == 0 )
            continue;
        Item@ item = GetItem( values[ i ] );
        if( valid( item ) )
            DeleteItem( item );
    }
    return 0;
}

void _FireInit( Item& item, bool firstTime )
{
    if( !firstTime )
        DeleteItem( item );
    else
    {
        SETFLAG( item.Flags, ITEM_NO_BLOCK );
        SETFLAG( item.Flags, ITEM_SHOOT_THRU );
        if( item.GetProtoId() == PID_FIRE_HEX )
        {
            item.SetEvent( ITEM_EVENT_WALK, "_FireHexWalk" );
        }
    }
}

void _FireHexWalk( Item& mine, Critter& cr, bool entered, uint8 dir )
{
    if( entered )
    {
        if( cr.IsPlayer())
		{	
			InjureCritter(cr,FIRE_STEP_ON,DAMAGE_FIRE,0,mine.Val0);
			cr.StatBase[ST_BURN_LAST_ENEMY_ID]=mine.Val0;
			cr.AddTimeEvent("cte_Burn",GetBurnDuration(cr),CTE_BURN);
			if((cr.StatBase[ST_BURN_STACK]>12)) cr.StatBase[ST_BURN_STACK]=12;
			else cr.StatBase[ST_BURN_STACK]+=4;
			//cr.RunClientScript("_FlushScreen",int(COLOR_LRED2),0,int(50),null,null);
        }
		else
        {
            if( cr.Mode[ MODE_INVULNERABLE ] == 0 )
			{
            InjureCritter(cr,FIRE_STEP_ON,DAMAGE_FIRE,0,mine.Val0);
			cr.AddTimeEvent("cte_Burn",GetBurnDuration(cr),CTE_POISON);
			cr.StatBase[ST_BURN_LAST_ENEMY_ID]=mine.Val0;
			if((cr.StatBase[ST_BURN_STACK]>12)) cr.StatBase[ST_BURN_STACK]=12;
			else cr.StatBase[ST_BURN_STACK]+=4;
			
			}
        }
    }
}

void AddFire( Map@ map, uint16 hexX, uint16 hexY, bool place, int16 pid, int ownerId, uint[]& ids )
{
    if( valid( map ) && place && ( map.IsHexPassed( hexX, hexY ) || valid( map.GetCritter( hexX, hexY ) ) ) )
    {
        Item@ item = map.AddItem( hexX, hexY, pid, 1 );
        if( valid( item ) )
        {
            item.Val0 = ownerId;
            ids.insertLast( item.Id );
            item.SetScript( "_FireInit" );
        }
    }
}

void MolotovBlast( Critter& cr, int pid, int, int )
{
    MolotovBlast( cr.GetMap(), cr.HexX, cr.HexY, uint16( pid ), cr.Id );
}

uint cte_Burn(Critter& cr, int identifier, uint& rate)
{
	if(cr.IsDead()) cr.StatBase[ST_BURN_STACK]=0;
	int count=cr.Stat[ST_BURN_STACK];
	cr.StatBase[ST_BURN_STACK]=CLAMP(count,0,12);
	count=cr.Stat[ST_BURN_STACK];
	if(count > 0)
	{
		InjureCritter(cr,BURN_DAMAGE,DAMAGE_FIRE,0,cr.Stat[ST_BURN_LAST_ENEMY_ID]);
		cr.StatBase[ST_BURN_STACK]-=1;
		if(cr.Stat[ST_CURRENT_HP]<=-19) cr.ToDead(ANIM2_DEAD_BURN,null);
	}
	return GetBurnDuration(cr);
}

uint GetBurnDuration(Critter& cr)
{
	int duration;
	int count=cr.Stat[ST_BURN_STACK];
	if(count==0) return 0;
	duration=count*3;
	if(duration<=0) cr.EraseTimeEvents(CTE_BURN);;
	return duration;
}