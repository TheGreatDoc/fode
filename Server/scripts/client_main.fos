#include "_client_defines.fos"
#include "_macros.fos"
#include "_msgstr.fos"
#include "sprite.fos"
#include "_colors.fos"
#include "_animation.fos"
#include "prefixes.fos"
#include "factions.fos"
#include "quests.fos"
#include "client_screen_dev_screenpanel.fos"
#include "client_screen_dev_critterpanel.fos"
#include "client_screen_dev_itempanel.fos"
#include "client_screen_dev_hexpanel.fos"
#include "client_screen_players_self_menu.fos"
#include "client_screen_players_hex_menu.fos"
#include "client_screen_players_item_menu.fos"
#include "client_screen_players_critter_menu.fos"
#include "client_screen_server_message.fos"
#include "client_screen_town_control.fos"
#include "client_screen_hex_shooting.fos"

import void InitializeGame() from "config";
import void InitAwarenessScreen() from "awareness";
import void updateAwarenessScreen(string[]& factionNames) from "awareness";
import void updateFactionsScreen(string[]& factionNames) from "client_screen_faction";
import void InitRadioScreen() from "client_screen_radio";
import void GUI_Init() from "client_gui";
import void GUI_GetActiveScreens(int[]& result) from "client_gui";
import void GUI_ShowScreen(int screenIndex, int p0, int p1, int p2) from "client_gui";
import void GUI_HideScreen(int screenIndex, int p0, int p1, int p2) from "client_gui";
import void GUI_Render(bool mainScreen) from "client_gui";
import bool GUI_MouseDown(int click, int x, int y) from "client_gui";
import bool GUI_MouseUp(int click, int x, int y) from "client_gui";
import void GUI_MouseMove(int x, int y) from "client_gui";
import bool GUI_KeyDown(uint8 key, string& keyText) from "client_gui";
import bool GUI_KeyUp(uint8 key, string& keyText) from "client_gui";
import void GUI_InputLost() from "client_gui";
import bool PerkCheck(CritterCl& cr, uint perk) from "perks";
import void CritterGenerate(int[]& data) from "parameters";
import bool CritterGenerateCheck(int[]& data) from "parameters";
import void InitNameColorizing() from "name_colorizing";
import bool TryColorizeCritter(CritterCl& cr) from "name_colorizing";
import bool PlayerIgnored(CritterCl& cr) from "ignore_list";
import bool IgnorePlayer(string& message) from "ignore_list";
import void InitIgnoreList() from "ignore_list";
import void InitChosenTabs() from "chosen_tabs";
import void DrawChosenTabs() from "chosen_tabs";
#ifdef PLAYERS_3D
import void Init3DChaRegScreen() from "client_3d_cha_reg";
import void Set3DRegistrationGender(int gender) from "client_3d_cha_reg";
import void Fill3DRegistrationParameters(int[]& params) from "client_3d_cha_reg";
#endif
import void PlayAnimSound(uint crType, int gender, uint anim1, uint anim2) from "animation";

import void ChosenReload_slot1() from "FODE_hotkeys";
import void ChosenReload_slot2() from "FODE_hotkeys";
import void Lecznik() from "FODE_hotkeys";
import void Doktornik() from "FODE_hotkeys";

import void InitTestScreen2() from "client_screen_test_2";
import void InitTimeoutInfo() from "timeout";
import void TimeoutUpdate() from "timeout";
import void TimeOutChangeVisibility() from "timeout";
import uint8 GetHotkey(string& iniKey, uint8 defaultValue) from "skrypty_client";
import void InitBankScreen() from "client_screen_bank";
import void InitNoBankScreen() from "client_screen_bank";
import void ShowBankScreen(int, int, int, string@, int[]@) from "client_screen_bank";
import void InitQuestScreen() from "client_screen_quest";
import void QuestNotificationUpdate() from "client_screen_quest";
import void UpdateQuestList(string quest_progress_str) from "client_screen_quest";
import void AddQuestNotification(string text1, string text2, string text3) from "client_screen_quest";
import void InitFactionScreen() from "client_screen_faction";
import void ShowFactionInvitationScreen(string message) from "client_screen_faction";
import void ShowFactionScreen() from "client_screen_faction";
import void InitChatScreen() from "client_screen_chat";
import void ShowChatScreen() from "client_screen_chat";
import void ProcessChatMessage(string message) from "client_screen_chat";
import void InitNewPipBoy() from "client_scripts";
import void InitStartMusic() from "client_scripts";
import void InitAutoAim() from "client_auto_aim";
import void AutoAimHotkey(uint8 key) from "client_auto_aim";
import int GetAutoAimHitLocation() from "client_auto_aim";
import void InitBaseTerminalScreen() from "client_screen_base_terminal";
import void InitEventPanelScreen() from "client_screen_event_panel";
import void InitOtherScreen() from "client_screen_other";
import void ShowOtherScreen() from "client_screen_other";
import void InitInvSlot() from "client_screen_inventory";
import void ShowSlotInv() from "client_screen_inventory";
import void InitScreenMain() from "client_screen_main";
import void InitDialogAvatar() from "client_screen_dialog";
import void GetDialogAvatar(uint dlgId) from "client_screen_dialog";
import void WM_Draw() from "client_worldmap";
import void WM_MouseMove() from "client_worldmap";
import bool WM_MouseUp(int click, int x, int y) from "client_worldmap";
import bool WM_MouseDown(int click, int x, int y) from "client_worldmap";
import void WM_Update(uint dt) from "client_worldmap";
import void InitBarterScreen() from "client_screen_barter";
import void InitEventBearlinePanelScreen() from "client_screen_eventberaline_panel";
import void InitItemCountsScreen() from "fo2155_client_screen_item_counter";
import void UpdateItemCountsScreen() from "fo2155_client_screen_item_counter";
import void ItemCountScreenMouseUp() from "fo2155_client_screen_item_counter";
import void InitCharacterScreen() from "client_screen_character";
import void SetNextLevelExp() from "client_screen_character";
import uint CheckPlayerName( const string& name ) from "parameters";

int PlayerDisplayType=PLAYER_DISPLAY_NAME;
int CurrentCommand=COMMAND_NONE;
int CurrentCommandLeaderX=0;
int CurrentCommandLeaderY=0;
int CurrentCommandX=0;
int CurrentCommandY=0;
Sprite CommandMoveSprite;
Sprite CommandAttackSprite;
Sprite CommandDefendSprite;
bool IsSnowing=false;
int ChosenHealth=999;
int visor = 0;
bool ColoredCombatMSG = true; //Переключатель между режимами цвета боевого лога
class SnowClass
{
	float x;
	float y;
	float arc;
	
	SnowClass(float new_x, float new_y)
	{
		x=new_x;
		y=new_y;
		arc=0.f;
	}
};
SnowClass []Snow;

//int BerlinSound1Timeout=100;
//int BerlinSound2Timeout=300;
int BerlinEffect1Timeout=5000;

////////////////////////////////////////////////////////////////////////////////////////////////////
// Call on client loaded or new client_main.fos script received.
bool start()
{
	InitializeGame();

	if(__ScreenWidth < 640 || __ScreenWidth > 1280 || __ScreenHeight < 480 || __ScreenHeight > 1024)
	{
		// Recomendation message
		Message(GetMsgStr(TEXTMSG_GAME, STR_INVALID_RESOLUTION));
	}


#ifdef PLAYERS_3D
	AppendIfaceIni("players3d_chareg.ini");
 #ifndef PLAYERS_3D_NO_HEAD
	AppendIfaceIni("players3d_headinv.ini");
 #endif
#endif

	LoadFont(FONT_COURIER_NEW_SMALL, "CourierNewSmall");
	// SetDefaultFont(FONT_COURIER_NEW_SMALL, COLOR_TEXT);

	GUI_Init();
	InitNameColorizing();
	InitIgnoreList();
	InitAwarenessScreen();
	//InitTestScreen();
	//InitTestScreen2();
	InitFactionScreen();
	InitBankScreen();
	InitNoBankScreen();
	InitAutoAim();
	InitDEVScreenPanel();
	InitDEVCritterPanel();
	InitDEVItemPanel();
	InitDEVHexPanel();
	InitPlayersSelfMenu();
	InitPlayersHexMenu();
	InitPlayersItemMenu();
	InitPlayersCritterMenu();
	InitChatScreen();
	InitServerMessageScreen();
	InitTcServerMessageScreen();
	InitQuestScreen();
	InitHexShootingScreen();
	InitNewPipBoy();
	InitBaseTerminalScreen();
	InitEventPanelScreen();
	InitStartMusic();
	InitRadioScreen();
	InitTimeoutInfo();
	InitParamScreen();
	InitOtherScreen();
	InitInvSlot();
	InitBarterScreen();
	InitScreenMain();
	__ShowPlayerNames = true;
	InitChosenTabs();
	InitDialogAvatar();
	InitEventBearlinePanelScreen();
	InitItemCountsScreen();
	InitCharacterScreen();
#ifdef PLAYERS_3D
	Init3DChaRegScreen();
#endif

	// 3d models preloading
#ifdef PLAYERS_3D
	// Mobs
/*	Load3dFile("VbAnt.fo3d"           , PT_ART_CRITTERS);
	Load3dFile("VbAntQueen.fo3d"      , PT_ART_CRITTERS);
	Load3dFile("VbBat.fo3d"           , PT_ART_CRITTERS);
	Load3dFile("VbBeetle.fo3d"        , PT_ART_CRITTERS);
	Load3dFile("VbCentipede.fo3d"     , PT_ART_CRITTERS);
	Load3dFile("VbCougar.fo3d"        , PT_ART_CRITTERS);
	Load3dFile("VbCow.fo3d"           , PT_ART_CRITTERS);
	Load3dFile("VbDeathclaw.fo3d"     , PT_ART_CRITTERS);
	Load3dFile("VbDesertStalker.fo3d" , PT_ART_CRITTERS);
	Load3dFile("VbDog.fo3d"           , PT_ART_CRITTERS);
	Load3dFile("VbGila.fo3d"          , PT_ART_CRITTERS);
	Load3dFile("VbMantrap.fo3d"       , PT_ART_CRITTERS);
	Load3dFile("VbRadToad.fo3d"       , PT_ART_CRITTERS);
	Load3dFile("VbRat.fo3d"           , PT_ART_CRITTERS);
	Load3dFile("VbThornSlinger.fo3d"  , PT_ART_CRITTERS);
	Load3dFile("VbAnt.fo3d"           , PT_ART_CRITTERS);
	Load3dFile("VbWaspGiant.fo3d"     , PT_ART_CRITTERS);
	Load3dFile("VbWeedling.fo3d"      , PT_ART_CRITTERS);*/
	// Critters
	Load3dFile("VbFemaleFat.fo3d"     , PT_ART_CRITTERS);
	Load3dFile("VbFemaleNormal.fo3d"  , PT_ART_CRITTERS);
	Load3dFile("VbFemaleStrong.fo3d"  , PT_ART_CRITTERS);
	Load3dFile("VbFemaleWiry.fo3d"    , PT_ART_CRITTERS);
	Load3dFile("VbFemaleSkeleton.fo3d", PT_ART_CRITTERS);
	Load3dFile("VbMaleFat.fo3d"       , PT_ART_CRITTERS);
	Load3dFile("VbMaleNormal.fo3d"    , PT_ART_CRITTERS);
	Load3dFile("VbMaleStrong.fo3d"    , PT_ART_CRITTERS);
	Load3dFile("VbMaleWiry.fo3d"      , PT_ART_CRITTERS);
	Load3dFile("VbMaleSkeleton.fo3d"  , PT_ART_CRITTERS);
#endif

	string path="intrface/command_move.png";
	CommandMoveSprite.Load(path,int(PT_ART));
	path="intrface/command_attack.png";
	CommandAttackSprite.Load(path,int(PT_ART));
	path="intrface/command_defend.png";
	CommandDefendSprite.Load(path,int(PT_ART));
	Message("FOnline: Desert Europe - PRIVATE ALPHA\nOnly for internal team. Test well <3");

	return true;
}

// Ask the server for all the factions existing
void __InitializeFactions(int, int, int, string@, int[]@) {
	string factionNames = " "; // We have to initialize the value with a character because else AS think its Null.
	RunServerScriptUnsafe("factions@unsafe_LoadFactions",0,0,0,factionNames,null); // We ask the server here
}

// The server call this function which ensure that the variable FACTIONS is filled with the correct values
void __FillFactionsVariable(int, int, int, string@ factionNames, int[]@)
{
    // We resize the FACTIONS variable to 0 to reset it
	FACTIONS.resize(0);

	// We split back the concatenated string into a string<array>
	array<string@> splittedFactionsNames = split(factionNames,"&");
	for(uint i = 0; i < splittedFactionsNames.length(); i++) {
		FACTIONS.insertLast(splittedFactionsNames[i]); // And we fill each cells of FACTIONS with the splitted values.
	}
}

////////////////////////////////////////////////////////////////////////////////////////////////////
//przedrostki 1
////////////////////////////////////////////////////////////////////////////////////////////////////
// Main loop function. Returned time of next call in milliseconds.
uint loop()  
{
	// We send the updated FACTIONS variable to the needed screens
	updateAwarenessScreen(FACTIONS);
	updateFactionsScreen(FACTIONS);
	
	TimeoutUpdate();
	if(__FullSecond>=ServerMessageDissappearTime)
	{
		ServerMessageTextOpt.setVisible(false);
		ServerMessageGlobalMapTextOpt.setVisible(false);
	}
	if(__FullSecond>=TcServerMessageDissappearTime)
	{
		TcServerMessageTextOpt.setVisible(false);
		TcServerMessageGlobalMapTextOpt.setVisible(false);
	}
	if(__FullSecond>=ServerNoteDissappearTime)
	{
		ServerMessageInfoRewardTextOpt.setVisible(false);
	}
	
	CritterCl@[] crs;
	GetCritters(0,FIND_ALL|FIND_ONLY_PLAYERS,crs);
	for(uint i=0; i<crs.length(); i++)
		{
			if(!crs[i].IsChosen())
			{
				if(crs[i].ParamBase[CRITER_VISIBLE]==1) crs[i].SetVisible(false);
				else crs[i].SetVisible(true);
			}
			if(crs[i].ContourColor==COLOR_CONTOUR_GREEN) crs[i].NameColor=COLOR_GREEN;
			else if(crs[i].ContourColor==COLOR_CONTOUR_RED) crs[i].NameColor=COLOR_RED;
			else if(crs[i].ContourColor!=COLOR_CONTOUR_YELLOW) crs[i].NameColor=crs[i].ContourColor;
			else crs[i].NameColor=COLOR_CRITTER_NAME;
			if(PlayerDisplayType==PLAYER_DISPLAY_NAME) 
			if(crs[i].ParamBase[SCOUT_MAIN_FACTION]==1)
				{
					crs[i].NameOnHead="|0x01000000 test";
				}
				else
				{
					crs[i].NameOnHead="";
				}
			if(PlayerDisplayType==PLAYER_DISPLAY_FACTION) 
			{
				if(crs[i].ParamBase[SCOUT_MAIN_FACTION]==1)
				{
				crs[i].NameOnHead="|0x01000000 test";
				}
				else if(crs[i].ParamBase[SCOUT_PLAYER_FACTION]==1)
				{
					crs[i].NameOnHead=FACTIONS[GetChosen().ParamBase[PLAYER_FACTION]];
				}
				else if(crs[i].ParamBase[SCOUT_PLAYER_FACTION]==2)
				{
					crs[i].NameOnHead="no faction";
				}
				else
				{
					crs[i].NameOnHead=FACTIONS[crs[i].ParamBase[PLAYER_FACTION]];
				}
			}
			else if(PlayerDisplayType==PLAYER_DISPLAY_MAIN_FACTION)
			{
				if(crs[i].ParamBase[SCOUT_MAIN_FACTION]==1)
				{
				crs[i].NameOnHead="|0x01000000 test";
				}
				else if(crs[i].ParamBase[SCOUT_MAIN_FACTION]==2 && GetChosen().ParamBase[PLAYER_MAIN_FACTION]==0)
				{
				crs[i].NameOnHead="no main faction";
				}
				else if(crs[i].ParamBase[SCOUT_MAIN_FACTION]==2 && GetChosen().ParamBase[PLAYER_MAIN_FACTION]==1)
				{
				crs[i].NameColor=COLOR_LRED2;
				crs[i].NameOnHead="REF";
				}
				else if(crs[i].ParamBase[SCOUT_MAIN_FACTION]==2 && GetChosen().ParamBase[PLAYER_MAIN_FACTION]==2)
				{
				crs[i].NameColor=COLOR_LBLUE2;
				crs[i].NameOnHead="NEC";
				}
				else if(crs[i].ParamBase[PLAYER_MAIN_FACTION]==0) crs[i].NameOnHead="no main faction";
				else if(crs[i].ParamBase[PLAYER_MAIN_FACTION]==1)
				{
					crs[i].NameColor=COLOR_LRED2;
					crs[i].NameOnHead="REF";
				}
				else if(crs[i].ParamBase[PLAYER_MAIN_FACTION]==2)
				{
					crs[i].NameColor=COLOR_LBLUE2;
					crs[i].NameOnHead="NEC";
				}
			}
		}
	
	QuestNotificationUpdate();

	uint16 hx=0;
	uint16 hy=0;
	if(GetCurrentCursor()==CURSOR_USE_WEAPON && CtrlDown && GetMonitorHex(__MouseX,__MouseY,hx,hy) && @GetMonitorCritter(__MouseX,__MouseY)==null) //получили гекс, который расположен под курсором
	{
		HexShootingHitChance.setVisible(true);
		HexShootingHitChance.AbsolutePosition(__MouseX+6,__MouseY+6);
		HexShootingHitChance.setText(GetHexShootingHitChance(hx,hy)+"%");
	}
	else HexShootingHitChance.setVisible(false);
	
	CritterCl @chosen=GetChosen();
	if(@chosen==null)
		CurrentCommand=COMMAND_NONE;
	else
	{
		int last_command=CurrentCommand;
		CritterCl @cr=GetCritter(GetChosen().ParamBase[ST_FOLLOW_CRIT]);
		if(chosen.ParamBase[ST_FOLLOW_CRIT]==0 || @cr==null)
		{
			if(chosen.ParamBase[PLAYER_COMMAND]!=COMMAND_NONE)
			{
				CurrentCommand=chosen.ParamBase[PLAYER_COMMAND];
				CurrentCommandLeaderX=chosen.HexX;
				CurrentCommandLeaderY=chosen.HexY;
				CurrentCommandX=chosen.ParamBase[PLAYER_COMMAND_X];
				CurrentCommandY=chosen.ParamBase[PLAYER_COMMAND_Y];
			}
			else CurrentCommand=COMMAND_NONE;
		}
		else
		{
			CurrentCommand=cr.ParamBase[PLAYER_COMMAND];
			CurrentCommandLeaderX=cr.HexX;
			CurrentCommandLeaderY=cr.HexY;
			CurrentCommandX=cr.ParamBase[PLAYER_COMMAND_X];
			CurrentCommandY=cr.ParamBase[PLAYER_COMMAND_Y];
		}
		if(last_command!=CurrentCommand)
		{
			//uint[] actions = { CHOSEN_USE_ITEM, 0, 120, TARGET_SELF_ITEM, 0, ITEM_MODE_RELOAD, 0 };
			//uint[] actions={CHOSEN_DIR,0,0,0,0,0,0};
			//SetChosenActions(actions);
			//Message("A");
		}
	}
	
	if(@chosen!=null) ChosenHealth=chosen.ParamBase[ST_CURRENT_HP];
	else ChosenHealth=999;
	
	if(Random(0,10)==0 && IsSnowing)
		for(int i=0; i<2; ++i) Snow.insertLast(SnowClass(Random(-5,__ScreenWidth),-Random(5,15)));
	for(uint i=0; i<Snow.length(); i++)
	{
		Snow[i].arc+=0.1;
		if(Snow[i].arc>3.14) Snow[i].arc=-3.14;
		Snow[i].y+=3.2;
		Snow[i].x+=sin(Snow[i].arc);
		if(Snow[i].y>__ScreenHeight || Snow[i].x<-6.f || Snow[i].x>__ScreenWidth+6.f)
			Snow.removeAt(i);
	}
//	Berlin war sounds in the background
//	BerlinSound1Timeout+=Random(0,50);
//	BerlinSound2Timeout+=Random(0,50);
	BerlinEffect1Timeout+=Random(0,50);
//	if(BerlinSound1Timeout>8000)
//	{
//		BerlinSound1Timeout=0;
//		if(GetCurrentMapPid()==695) PlaySound("berlin_howitzer.ogg");
//	}
//	if(BerlinSound2Timeout>13000)
//	{
//		BerlinSound2Timeout=0;
//		if(GetCurrentMapPid()==695) PlaySound("berlin_shots.ogg");
//	}
	if(BerlinEffect1Timeout>23000)
	{
		BerlinEffect1Timeout=0;
		if(GetCurrentMapPid()==695)
		{
			QuakeScreen(2,900);
			PlaySound("berlin_bomb.ogg");
		}
	}
	ShowSlotInv();
	UpdateItemCountsScreen();
	WM_Update(50);
	
	return 10;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
// Say to engine what screens is active.
void get_active_screens(int[]& result)
{
	GUI_GetActiveScreens(result);
}

////////////////////////////////////////////////////////////////////////////////////////////////////
// Show/hide screen behaviour.
void screen_change(bool show, int screen, int p0, int p1, int p2)
{
	SetNextLevelExp();
	if(show)
		GUI_ShowScreen(screen, p0, p1, p2);
	else
		GUI_HideScreen(screen, p0, p1, p2);
}

////////////////////////////////////////////////////////////////////////////////////////////////////
// Render interface function. You can use Draw* functions only there.
// Layer specification:
//    1
// Game map
//    2
// Console, Messbox
//    3
// PopUp menu, Cursor
//    4
// Extra layers:
// Global map
//    100 (over map), 101 (over all)
float a=0;
void render_iface(uint layer)
{
	if(layer == 2)
	{
		if(CurrentCommand!=COMMAND_NONE)
		{
			int x=0,y=0;
			GetHexPos(CurrentCommandLeaderX,CurrentCommandLeaderY,x,y);
			int x2=0,y2=0;
			GetHexPos(CurrentCommandX,CurrentCommandY,x2,y2);
			if(CurrentCommand==COMMAND_MOVE)
			{
				int[]data={x,y,0x7F0042BA,x2,y2,0x7F0042BA};
				DrawPrimitive(DRAW_PRIMITIVE_LINESTRIP,data);
				DrawSprite(CommandMoveSprite.Id,0,x2-16,y2-43,0);
			}
			else if(CurrentCommand==COMMAND_ATTACK)
			{
				int[]data={x,y,0x7FCC0000,x2,y2,0x7FCC0000};
				DrawPrimitive(DRAW_PRIMITIVE_LINESTRIP,data);
				DrawSprite(CommandAttackSprite.Id,0,x2-16,y2-43,0);
			}
			else if(CurrentCommand==COMMAND_DEFEND)
			{
				int[]data={x,y,0x7FC8300BA,x2,y2,0x7FC8300BA};
				DrawPrimitive(DRAW_PRIMITIVE_LINESTRIP,data);
				DrawSprite(CommandDefendSprite.Id,0,x2-16,y2-43,0);
			}
		}
		
 			uint16 hx=0;
			uint16 hy=0;
		if(GetCurrentCursor()==CURSOR_USE_WEAPON && CtrlDown && GetMonitorHex(__MouseX,__MouseY,hx,hy))
		{
			int x1=0, y1=0; //1st coordinate
			int x2=0, y2=0; //2nd
			int x3=0, y3=0;
			int x4=0, y4=0;
			int x5=0, y5=0;
			int x6=0, y6=0; //6th
			int a=0;		//radius of hex
			CritterCl@ chosen = GetChosen();
			if(valid(chosen))
			{
				uint8 weaponMode=0;
				ProtoItem @weapon=chosen.GetSlotProto(SLOT_HAND1,weaponMode);
				ProtoItem@ ammo = null;
				if( valid ( weapon ) )
				{
				int use         = _WeaponModeUse(weaponMode);
				uint skillNum = _WeaponSkill(weapon, use);
				uint damageType = _WeaponDmgType(weapon, use);
				int wpnMaxDist = _WeaponMaxDist(weapon, use);
				int dist = GetDistantion(chosen.HexX,chosen.HexY,hx,hy);
				uint WeaponId = weapon.ProtoId;
				//hex forand nades a=radius
				if ( skillNum == SK_THROWING && ( WeaponId == PID_PULSE_GRENADE_DE || WeaponId == PID_PLASMA_GRENADE_DE ||  WeaponId == PID_FRAG_GRENADE_DE ||  WeaponId == PID_MOLOTOV_COCKTAIL_DE) ) 
					{
						a=2;
						MoveHexByDir(hx, hy, 0, a);
						GetHexPos(hx, hy, x1, y1);		
						MoveHexByDir(hx, hy, 2, a);	
						GetHexPos(hx, hy, x2, y2);		
						MoveHexByDir(hx, hy, 3, a);	
						GetHexPos(hx, hy, x3, y3);		
						MoveHexByDir(hx, hy, 4, a);	
						GetHexPos(hx, hy, x4, y4);		
						MoveHexByDir(hx, hy, 5, a);	
						GetHexPos(hx, hy, x5, y5);		
						MoveHexByDir(hx, hy, 0, a);	
						GetHexPos(hx, hy, x6, y6);		
		
						int[]data={x1,y1,0x7FCC0000,x2,y2,0x7FCC0000,x3,y3,0x7FCC0000,x4,y4,0x7FCC0000,x5,y5,0x7FCC0000,x6,y6,0x7FCC0000,x1,y1,0x7FCC0000};
						DrawPrimitive(DRAW_PRIMITIVE_LINESTRIP,data);	
						DrawPrimitive(DRAW_PRIMITIVE_LINESTRIP,data);
						DrawPrimitive(DRAW_PRIMITIVE_LINESTRIP,data);
						DrawPrimitive(DRAW_PRIMITIVE_LINESTRIP,data);	
						DrawPrimitive(DRAW_PRIMITIVE_LINESTRIP,data);
						DrawPrimitive(DRAW_PRIMITIVE_LINESTRIP,data);
						DrawPrimitive(DRAW_PRIMITIVE_LINESTRIP,data);	
						DrawPrimitive(DRAW_PRIMITIVE_LINESTRIP,data);
						DrawPrimitive(DRAW_PRIMITIVE_LINESTRIP,data);
						DrawPrimitive(DRAW_PRIMITIVE_LINESTRIP,data);					
					}
				 //hex for rocket launcer and nade launcher attacks a=radius
				else if ( WeaponId == PID_ROCKETRAD_DE || WeaponId == PID_ROCKETELE_DE || WeaponId == PID_ROCKET_LAUNCHER_DE || WeaponId == PID_M32_DE || WeaponId == PID_M32S_DE )
					{
						a=3;
						MoveHexByDir(hx, hy, 0, a);
						GetHexPos(hx, hy, x1, y1);		
						MoveHexByDir(hx, hy, 2, a);	
						GetHexPos(hx, hy, x2, y2);		
						MoveHexByDir(hx, hy, 3, a);	
						GetHexPos(hx, hy, x3, y3);		
						MoveHexByDir(hx, hy, 4, a);	
						GetHexPos(hx, hy, x4, y4);		
						MoveHexByDir(hx, hy, 5, a);	
						GetHexPos(hx, hy, x5, y5);		
						MoveHexByDir(hx, hy, 0, a);	
						GetHexPos(hx, hy, x6, y6);		
		
						int[]data={x1,y1,0x7FCC0000,x2,y2,0x7FCC0000,x3,y3,0x7FCC0000,x4,y4,0x7FCC0000,x5,y5,0x7FCC0000,x6,y6,0x7FCC0000,x1,y1,0x7FCC0000};
						DrawPrimitive(DRAW_PRIMITIVE_LINESTRIP,data);	
						DrawPrimitive(DRAW_PRIMITIVE_LINESTRIP,data);
						DrawPrimitive(DRAW_PRIMITIVE_LINESTRIP,data);
						DrawPrimitive(DRAW_PRIMITIVE_LINESTRIP,data);	
						DrawPrimitive(DRAW_PRIMITIVE_LINESTRIP,data);
						DrawPrimitive(DRAW_PRIMITIVE_LINESTRIP,data);
						DrawPrimitive(DRAW_PRIMITIVE_LINESTRIP,data);	
						DrawPrimitive(DRAW_PRIMITIVE_LINESTRIP,data);
						DrawPrimitive(DRAW_PRIMITIVE_LINESTRIP,data);
						DrawPrimitive(DRAW_PRIMITIVE_LINESTRIP,data);
					}
				 //cone for flamer hex attack		
				else if ( (WeaponId == PID_FLAMER_DE || WeaponId == PID_IMPROVED_FLAMETHROWER_DE || WeaponId == PID_FLAMERN_DE))
					{
						int HexDir=GetDirection(chosen.HexX,chosen.HexY,hx,hy);
						GetHexPos(chosen.HexX,chosen.HexY,x1,y1); //chosen hex 
						//GetHexPos(hx, hy, x3, y3);  			  //cursor hex
						int chosenX=0, chosenY=0; //координаты чузена
						uint16 chosenUX=0, chosenUY=0; 
						//int distantion=GetDistantion(x1, y1, x3, y3);
						chosenUX=chosen.HexX; chosenUY=chosen.HexY; //перевод координат гекса криттера в uint16
						MoveHexByDir(chosenUX, chosenUY, HexDir, 5); //двигаем в направлении курсора на 5 гексов
						GetHexPos(chosenUX, chosenUY, x3, y3); //
						
						x2=0; y2=0; x4=0; y4=0;
						if (HexDir==0) //
						{	
						MoveHexByDir(chosenUX, chosenUY, 4, 2);
						GetHexPos(chosenUX, chosenUY, x2, y2);
						MoveHexByDir(chosenUX, chosenUY, 1, 2);
						MoveHexByDir(chosenUX, chosenUY, 2, 2);
						GetHexPos(chosenUX, chosenUY, x4, y4);						
						int[]cone={x1,y1,0x7FCC0000,x2,y2,0x7FCC0000,x3,y3,0x7FCC0000,x4,y4,0x7FCC0000,x1,y1,0x7FCC0000};
						for(uint i=0; i<11; i++) DrawPrimitive(DRAW_PRIMITIVE_LINESTRIP,cone);						
						}
						else if (HexDir==1)
						{				
						MoveHexByDir(chosenUX, chosenUY, 5, 2);
						GetHexPos(chosenUX, chosenUY, x2, y2);
						MoveHexByDir(chosenUX, chosenUY, 2, 2);
						MoveHexByDir(chosenUX, chosenUY, 3, 2);
						GetHexPos(chosenUX, chosenUY, x4, y4);
						int[]cone={x1,y1,0x7FCC0000,x2,y2,0x7FCC0000,x3,y3,0x7FCC0000,x4,y4,0x7FCC0000,x1,y1,0x7FCC0000};
						for(uint i=0; i<11; i++) DrawPrimitive(DRAW_PRIMITIVE_LINESTRIP,cone);						
						}
						else if (HexDir==2)
						{
						MoveHexByDir(chosenUX, chosenUY, 0, 2);
						GetHexPos(chosenUX, chosenUY, x2, y2);
						MoveHexByDir(chosenUX, chosenUY, 3, 2);
						MoveHexByDir(chosenUX, chosenUY, 4, 2);
						GetHexPos(chosenUX, chosenUY, x4, y4);
						int[]cone={x1,y1,0x7FCC0000,x2,y2,0x7FCC0000,x3,y3,0x7FCC0000,x4,y4,0x7FCC0000,x1,y1,0x7FCC0000};
						for(uint i=0; i<11; i++) DrawPrimitive(DRAW_PRIMITIVE_LINESTRIP,cone);						
						}
						else if (HexDir==3)
						{
						MoveHexByDir(chosenUX, chosenUY, 1, 2);
						GetHexPos(chosenUX, chosenUY, x2, y2);
						MoveHexByDir(chosenUX, chosenUY, 4, 2);
						MoveHexByDir(chosenUX, chosenUY, 5, 2);
						GetHexPos(chosenUX, chosenUY, x4, y4);
						int[]cone={x1,y1,0x7FCC0000,x2,y2,0x7FCC0000,x3,y3,0x7FCC0000,x4,y4,0x7FCC0000,x1,y1,0x7FCC0000};
						for(uint i=0; i<11; i++) DrawPrimitive(DRAW_PRIMITIVE_LINESTRIP,cone);						
						}
						else if (HexDir==4)
						{
						MoveHexByDir(chosenUX, chosenUY, 2, 2);
						GetHexPos(chosenUX, chosenUY, x2, y2);
						MoveHexByDir(chosenUX, chosenUY, 5, 2);
						MoveHexByDir(chosenUX, chosenUY, 0, 2);
						GetHexPos(chosenUX, chosenUY, x4, y4);
						int[]cone={x1,y1,0x7FCC0000,x2,y2,0x7FCC0000,x3,y3,0x7FCC0000,x4,y4,0x7FCC0000,x1,y1,0x7FCC0000};
						for(uint i=0; i<11; i++) DrawPrimitive(DRAW_PRIMITIVE_LINESTRIP,cone);								
						}
						else if (HexDir==5)
						{
						MoveHexByDir(chosenUX, chosenUY, 3, 2);
						GetHexPos(chosenUX, chosenUY, x2, y2);
						MoveHexByDir(chosenUX, chosenUY, 0, 2);
						MoveHexByDir(chosenUX, chosenUY, 1, 2);
						GetHexPos(chosenUX, chosenUY, x4, y4);	
						int[]cone={x1,y1,0x7FCC0000,x2,y2,0x7FCC0000,x3,y3,0x7FCC0000,x4,y4,0x7FCC0000,x1,y1,0x7FCC0000};
						for(uint i=0; i<11; i++) DrawPrimitive(DRAW_PRIMITIVE_LINESTRIP,cone);	
						}
						else return;
					}
				}
			}
		} 
		
		for(uint i=0; i<Snow.length(); i++)
		{
			int[]data={Snow[i].x,Snow[i].y,0x7FFFFFFF,Snow[i].x+2.f,Snow[i].y+2.f,0x7FFFFFFF,Snow[i].x+2.f,Snow[i].y+4.f,0x7FFFFFFF,Snow[i].x,Snow[i].y+6.f,0x7FFFFFFF,Snow[i].x-2.f,Snow[i].y+4.f,0x7FFFFFFF,Snow[i].x-2.f,Snow[i].y+2.f,0x7FFFFFFF};
			DrawPrimitive(DRAW_PRIMITIVE_TRIANGLEFAN,data);
		}
		/*if(ChosenHealth<=50)
		{
			int alpha=0;
			if(__FullSecond%28<14) alpha=__FullSecond%14;
			else alpha=14-__FullSecond%14;
			int[]data={0,0,int((alpha*7)<<24),__ScreenWidth,0,int((alpha*7)<<24),__ScreenWidth,__ScreenHeight,int((alpha*7)<<24),0,__ScreenHeight,int((alpha*7)<<24)};
			//int[]data={0,0,int((((alpha*5)<<8)|255)<<16),__ScreenWidth,0,int((alpha*5)<<24),__ScreenWidth,__ScreenHeight,int((alpha*5)<<24),0,__ScreenHeight,int((alpha*5)<<24)};
			DrawPrimitive(DRAW_PRIMITIVE_TRIANGLEFAN,data);
		}*/
	}
	if(layer == 2 && visor==1)
	{
		CritterCl@ cr = GetChosen();
		CritterCl@[]  critters;
		GetCrittersHex (cr.HexX, cr.HexY, 80, FIND_LIFE, critters);
		int x = 0; 
		int y = 0;
		
		if(critters.length()>0)
		{
			for(uint i=0,j=critters.length();i<j;i++)
			{
				bool crsGM=true;
				for(uint i=0; i<PREFIXES.length(); i++)
				{
					if(critters[i].Name==PREFIXES[i][0]) crsGM=false;
				}
				if ((critters[i].Id!=cr.Id && (critters[i].IsLife() || critters[i].IsKnockout())) && crsGM)
				{
					GetHexPos (critters[i].HexX, critters[i].HexY, x, y);
					if(cr.PerkBase[301]!=0)
					{
						string EYE = "";
						string RIGHT_ARM = "";
						string LEFT_ARM = "";
						string RIGHT_LEG = "";
						string LEFT_LEG = "";
						if(critters[i].Damage[DAMAGE_EYE]!=0)EYE = "E";
						if(critters[i].Damage[DAMAGE_RIGHT_ARM]!=0)RIGHT_ARM = "RA";
						if(critters[i].Damage[DAMAGE_LEFT_ARM]!=0)LEFT_ARM = "LA";
						if(critters[i].Damage[DAMAGE_RIGHT_LEG]!=0)RIGHT_LEG = "RL";
						if(critters[i].Damage[DAMAGE_LEFT_LEG]!=0)LEFT_LEG = "LL";
						string textD = "" + EYE + " " + RIGHT_ARM + " " + LEFT_ARM + " " + RIGHT_LEG + " " + LEFT_LEG;
						DrawText(textD, (x - 46) / __GmapZoom, (y - 105) / __GmapZoom, 90, 10, COLOR_DRED, FONT_FALLOUT, FT_CENTERXY);
						string text = "" + critters[i].Stat[ST_CURRENT_HP] + "/" + critters[i].Stat[ST_MAX_LIFE];
						DrawText(text, (x - 46) / __GmapZoom, (y - 95) / __GmapZoom, 90, 10, 0, FONT_FALLOUT, FT_CENTERXY);
					}
				}
			}
		}
	}
	if(layer == 2)
	{
		GUI_Render( true );
	}
	else if(layer == 3)
	{
		DrawChosenTabs();
		GUI_Render( false );
	}

	if(layer == 100 && __GmapActive)
	{
		WM_Draw();
		// Here you can draw on global map

		// bool  __GmapActive - Р°РєС‚РёРІРЅР° Р»Рё РіР»РѕР±Р°Р»СЊРЅР°СЏ РєР°СЂС‚Р° Рё РІСЃРµ Р»Рё СЃР»РµРґСѓСЋС‰РёРµ РЅРёР¶РµРїСЂРёРІРµРґРµРЅРЅС‹Рµ РїРµСЂРµРјРµРЅРЅС‹Рµ РєРѕСЂСЂРµРєС‚РЅС‹;
		// bool  __GmapWait   - РІРєР»СЋС‡РµРЅ СЂРµР¶РёРј РѕР¶РёРґР°РЅРёСЏ РѕС‚РІРµС‚Р° Рѕ РїРѕРґС‚РІРµСЂР¶РґРµРЅРёРё СЌРЅРєР°СѓРЅС‚РµСЂР°;
		// float __GmapZoom   - С‚РµРєСѓС‰РёР№ РјР°СЃС€С‚Р°Р±, РЅРµ Р·Р°Р±С‹РІР°Р№С‚Рµ СѓС‡РёС‚С‹РІР°С‚СЊ РµРіРѕ РїСЂРё СЂРёСЃРѕРІР°РЅРёРё РЅР° РєР°СЂС‚Рµ;
		// int   __GmapOffsetX/Y   - СЃРјРµС‰РµРЅРёРµ РєР°СЂС‚С‹ РѕС‚ РЅСѓР»РµРІРѕР№ РєРѕРѕСЂРґРёРЅР°С‚С‹ (РІРµСЂС…РЅРёР№-Р»РµРІС‹Р№ СѓРіРѕР»);
		// int   __GmapGroupCurX/Y - РєРѕРѕСЂРґРёРЅР°С‚С‹ РіСЂСѓРїРїС‹ РёРіСЂРѕРєР°;
		// int   __GmapGroupToX/Y  - РєРѕРѕСЂРґРёРЅР°С‚С‹ С‚РѕС‡РєРё РЅР°Р·РЅР°С‡РµРЅРёСЏ;
		// float __GmapGroupSpeed  - С‚РµРєСѓС‰Р°СЏ СЃРєРѕСЂРѕСЃС‚СЊ РїРµСЂРµРґРІРёР¶РµРЅРёСЏ.
		// Р”Р»СЏ РїСЂРёРјРµСЂР°, СЂР°СЃС‡РµС‚ С‚РµРєСѓС‰РµРіРѕ РїРёРєСЃРµР»СЏ РіСЂСѓРїРїС‹:
		// x = __GmapGroupX / __GmapZoom + __GmapOffsetX, y = __GmapGroupY / __GmapZoom + __GmapOffsetY.
	}
}

////////////////////////////////////////////////////////////////////////////////////////////////////
// Render map function. You can use DrawMap* functions only there. This drawing before 1 iface layer.
void render_map()
{
	//if(CurrentCommand==COMMAND_MOVE) DrawMapSprite(CurrentCommandX,CurrentCommandY,0,CommandMoveSprite.Id,-1,0,7);
	//else if(CurrentCommand==COMMAND_ATTACK) DrawMapSprite(CurrentCommandX,CurrentCommandY,0,CommandAttackSprite.Id,-1,0,7);
	//else if(CurrentCommand==COMMAND_DEFEND) DrawMapSprite(CurrentCommandX,CurrentCommandY,0,CommandDefendSprite.Id,-1,0,7);
}

bool AltDown = false;
bool CtrlDown = false;
bool SpaceDown = false;
bool MouseClickLeftDown = false;
bool MouseClickRightDown = false;
////////////////////////////////////////////////////////////////////////////////////////////////////
// Mouse behaviours. Click states look in _client_defines.fos, Mouse click states.
// Return true to disable engine events.
bool mouse_down(int click)
{
	if(click==MOUSE_CLICK_LEFT) MouseClickLeftDown=true;
	if(click==MOUSE_CLICK_RIGHT) MouseClickRightDown=true;
	if((click==MOUSE_CLICK_LEFT || click==MOUSE_CLICK_RIGHT) && SpaceDown) return true;
	
	if(click==MOUSE_CLICK_RIGHT && !AltDown)
	{
		HideScreen(CLIENT_SCREEN_DEV_HEXPANEL,0,0,0);
		HideScreen(CLIENT_SCREEN_DEV_ITEMPANEL,0,0,0);
		HideScreen(CLIENT_SCREEN_DEV_CRITTERPANEL,0,0,0);
		HideScreen(CLIENT_SCREEN_PLAYERS_SELF_MENU,0,0,0);
		HideScreen(CLIENT_SCREEN_PLAYERS_HEX_MENU,0,0,0);
		HideScreen(CLIENT_SCREEN_PLAYERS_ITEM_MENU,0,0,0);
		HideScreen(CLIENT_SCREEN_PLAYERS_CRITTER_MENU,0,0,0);
	}
	if(click==MOUSE_CLICK_RIGHT)
	{
		if(AltDown)
		{
			uint16 command_x=0,command_y=0;
			if(GetMonitorHex(__MouseX,__MouseY,command_x,command_y))
			{
				RunServerScriptUnsafe("server_scripts@unsafe_command",COMMAND_MOVE,command_x,command_y,null,null);
				return true;
			}
		}
	}
	if(click==MOUSE_CLICK_MIDDLE)
	{
		HideScreen(CLIENT_SCREEN_DEV_HEXPANEL,0,0,0);
		HideScreen(CLIENT_SCREEN_DEV_ITEMPANEL,0,0,0);
		HideScreen(CLIENT_SCREEN_DEV_CRITTERPANEL,0,0,0);
		HideScreen(CLIENT_SCREEN_PLAYERS_SELF_MENU,0,0,0);
		HideScreen(CLIENT_SCREEN_PLAYERS_HEX_MENU,0,0,0);
		HideScreen(CLIENT_SCREEN_PLAYERS_ITEM_MENU,0,0,0);
		HideScreen(CLIENT_SCREEN_PLAYERS_CRITTER_MENU,0,0,0);

		bool AccessToDEVPanel = (GetChosen().ParamBase[PLAYER_ACCESS] == ACCESS_ADMIN) ? true : false;

		if(AccessToDEVPanel && GetCurrentMapPid()!=0)
		{
			CritterCl @cr = GetMonitorCritter(__MouseX,__MouseY);
			ItemCl @it = GetMonitorItem(__MouseX,__MouseY);
			if(@cr!=null)
			{
				PointedCritterId=cr.Id;
				DEVCritterPanelOpt.Position(__MouseX+30,__MouseY+30);
				ShowScreen(CLIENT_SCREEN_DEV_CRITTERPANEL,0,0,0);
			}
			else if(@it!=null)
			{
				PointedItemId=it.Id;
				DEVItemPanelOpt.Position(__MouseX+30,__MouseY+30);
				ShowScreen(CLIENT_SCREEN_DEV_ITEMPANEL,0,0,0);
			}
			else
			{
				if(GetMonitorHex(__MouseX,__MouseY,PointedX,PointedY))
				{
					DEVHexPanelOpt.Position(__MouseX+30,__MouseY+30);
					ShowScreen(CLIENT_SCREEN_DEV_HEXPANEL,0,0,0);
				}
			}
			ChangeCursor(0);
		}
	}
	if(click==MOUSE_CLICK_LEFT)
	{
		if(AltDown && GetCurrentMapPid()!=0)
		{
			HideScreen(CLIENT_SCREEN_DEV_HEXPANEL,0,0,0);
			HideScreen(CLIENT_SCREEN_DEV_ITEMPANEL,0,0,0);
			HideScreen(CLIENT_SCREEN_DEV_CRITTERPANEL,0,0,0);
			HideScreen(CLIENT_SCREEN_PLAYERS_SELF_MENU,0,0,0);
			HideScreen(CLIENT_SCREEN_PLAYERS_HEX_MENU,0,0,0);
			HideScreen(CLIENT_SCREEN_PLAYERS_ITEM_MENU,0,0,0);
			HideScreen(CLIENT_SCREEN_PLAYERS_CRITTER_MENU,0,0,0);
			CritterCl @cr = GetMonitorCritter(__MouseX,__MouseY);
			ItemCl @it = GetMonitorItem(__MouseX,__MouseY);
			if(@cr!=null)
			{
				if(cr.Id==GetChosen().Id)
				{
					PlayersSelfMenuOpt.Position(__MouseX+30,__MouseY+30);
					ShowScreen(CLIENT_SCREEN_PLAYERS_SELF_MENU,0,0,0);
				}
				else
				{
					PlayersMenuPointedCritterId=cr.Id;
					PlayersCritterMenuOpt.Position(__MouseX+30,__MouseY+30);
					ShowScreen(CLIENT_SCREEN_PLAYERS_CRITTER_MENU,0,0,0);
				}
			}
			else if(@it!=null)
			{
				PlayersMenuPointedItemId=it.Id;
				PlayersItemMenuOpt.Position(__MouseX+30,__MouseY+30);
				ShowScreen(CLIENT_SCREEN_PLAYERS_ITEM_MENU,0,0,0);
			}
			else
			{
				if(GetMonitorHex(__MouseX,__MouseY,PlayersMenuPointedX,PlayersMenuPointedY))
				{
					PlayersHexMenuOpt.Position(__MouseX+30,__MouseY+30);
					ShowScreen(CLIENT_SCREEN_PLAYERS_HEX_MENU,0,0,0);
				}
			}
			ChangeCursor(0);
		}
		if(GetCurrentCursor()==CURSOR_USE_WEAPON && CtrlDown)
		{
			uint16 hx=0;
			uint16 hy=0;
			if(GetMonitorHex(__MouseX,__MouseY,hx,hy))
			{
				bool AllowShoot=false;
				if(@GetMonitorCritter(__MouseX,__MouseY)==null) AllowShoot=true;
				//else if(GetMonitorCritter(__MouseX,__MouseY).ParamBase[ST_CURRENT_HP]<=0) AllowShoot=true;
				RunServerScriptUnsafe("hex_shooting_server_scripts@unsafe_shoot_to_hex",hx,hy,0,null,null);
			}
		}
		if(GetCurrentMapPid()!=0)
		{
			CritterCl @cr = GetMonitorCritter(__MouseX,__MouseY);
			if(valid(cr))
			{	
				uint dlgId=cr.Stat[ST_DIALOG_ID];
				if(dlgId>0) GetDialogAvatar(dlgId);
			}
		
		}
	}
	return GUI_MouseDown(click, __MouseX, __MouseY);
}

bool mouse_up(int click)
{
	ItemCountScreenMouseUp();
	if(click==MOUSE_CLICK_LEFT) MouseClickLeftDown=false;
	if(click==MOUSE_CLICK_RIGHT) MouseClickRightDown=false;
	return GUI_MouseUp(click, __MouseX, __MouseY);
}

void mouse_move(int x, int y)
{
	// x == __MouseX
	// y == __MouseY
	GUI_MouseMove(x, y);
}

////////////////////////////////////////////////////////////////////////////////////////////////////
// Keyboard behaviours. Key codes look in _client_defines.fos DirectInput keyboard scan codes.
// Return true to disable engine events.
bool key_down(uint8 key, string& keyText)
{
	if(AltDown) AutoAimHotkey(key);
	if(key == DIK_LMENU || key == DIK_RMENU) AltDown=true;
	if(key == DIK_LCONTROL || key == DIK_RCONTROL) CtrlDown=true;
	if(key == DIK_SPACE) SpaceDown=true;
	/*if( __OpenGLRendering )
    {
        if( AltDown && key == DIK_Q )
            SetEffect( EFFECT_FLUSH_MAP, 0, null );
        if( AltDown && key == DIK_W )
            SetEffect( EFFECT_FLUSH_MAP, 0, "Flush_Map_BlackWhite.glsl" );
    }
    else
    {
        int effectType = EFFECT_2D_GENERIC | EFFECT_2D_CRITTER | EFFECT_2D_TILE | EFFECT_2D_ROOF | EFFECT_2D_RAIN;
        if( AltDown && key == DIK_Q )
            SetEffect( effectType, 0, null );
        if( AltDown && key == DIK_W )
            SetEffect( effectType, 0, "2D_BlackWhite.fx" );
    }*/
	if(!AltDown && key == GetHotkey("reloads1", DIK_R)) ChosenReload_slot1();
	if(AltDown && key == GetHotkey("reloads2", DIK_R)) ChosenReload_slot2();
	if(AltDown && key == GetHotkey("firstaid", DIK_5)) Lecznik();
	if(AltDown && key == GetHotkey("doctor", DIK_6)) Doktornik();
	if(AltDown && key == GetHotkey("timeout", DIK_T)) TimeOutChangeVisibility();
	if(CtrlDown && key == DIK_D) RunServerScriptUnsafe("FODE_hotkeys_dropandpick@unsafe_Drop_All",GetChosen().Id,0,0,null,null);
	if(CtrlDown && key == DIK_G) RunServerScriptUnsafe("FODE_hotkeys_dropandpick@unsafe_Take_All",GetChosen().Id,0,0,null,null);
	if (AltDown && key == GetHotkey("visor",DIK_V))
	{
	if(visor==0)
		{
		visor = 1;	
		}
	else visor = 0;
	}
	
	if( CtrlDown && key == DIK_1 ) RunServerScriptUnsafe("tactic@unsafe_tactic_agressive",0,0,0,null,null);
	if( CtrlDown && key == DIK_2 ) RunServerScriptUnsafe("tactic@unsafe_tactic_normal",0,0,0,null,null);
	if( CtrlDown && key == DIK_3 ) RunServerScriptUnsafe("tactic@unsafe_tactic_defensive",0,0,0,null,null);
	
	int[] ActiveScreens;
	GUI_GetActiveScreens(ActiveScreens);
	uint len=ActiveScreens.length();
	if(len!=0)
	{
		if(key == DIK_S && ActiveScreens[len-1] == CLIENT_SCREEN_SKILLBOX)
		{
			GUI_HideScreen(CLIENT_SCREEN_SKILLBOX, 0, 0, 0);
			return true;
		}
		if(key == DIK_O && ActiveScreens[len-1] == CLIENT_SCREEN_MENU)
		{
			GUI_HideScreen(CLIENT_SCREEN_MENU, 0, 0, 0);
			return true;
		}
	}
	
	uint16 barrel_x=0,barrel_y=0;
	if(GetMonitorHex(__MouseX,__MouseY,barrel_x,barrel_y))
		if(AltDown && key == DIK_B) RunServerScriptUnsafe("server_scripts@unsafe_test_barrel",barrel_x,barrel_y,0,null,null);
	uint16 command_x=0,command_y=0;
	if(GetMonitorHex(__MouseX,__MouseY,command_x,command_y))
	{
		if(AltDown && key==DIK_1) RunServerScriptUnsafe("server_scripts@unsafe_command",COMMAND_MOVE,command_x,command_y,null,null);
		if(AltDown && key==DIK_2) RunServerScriptUnsafe("server_scripts@unsafe_command",COMMAND_ATTACK,command_x,command_y,null,null);
		if(AltDown && key==DIK_3) RunServerScriptUnsafe("server_scripts@unsafe_command",COMMAND_DEFEND,command_x,command_y,null,null);
	}
	
	if(key == GetHotkey("change_text_on_head", DIK_V))
	{
		bool Change=true;
		int[]active_screens;
		get_active_screens(active_screens);
		if(@active_screens!=null)
		{
			if(active_screens.length()!=1) Change=false;
			else if(active_screens[0]!=CLIENT_MAIN_SCREEN_GAME) Change=false;
		}
		else Change=false;
		if(__ConsoleActive == true) Change=false;
		if(Change)
		{
			PlayerDisplayType=(PlayerDisplayType+1)%3;
			return false;
        }
	}
    if(key == GetHotkey("chat", DIK_U))
	{
		bool Open=true;
		int[]active_screens;
		get_active_screens(active_screens);
		if(@active_screens!=null)
		{
			if(active_screens.length()!=1) Open=false;
			else if(active_screens[0]!=CLIENT_MAIN_SCREEN_GAME) Open=false;
		}
		else Open=false;
		if(__ConsoleActive == true) Open=false;
		if(Open)
		{
			ChangeCursor(0);
			ShowChatScreen();
			return false;
        }
	}
	if(!AltDown && !CtrlDown && key == GetHotkey("zoom",DIK_Z) )
        __MapZooming = true;
	return GUI_KeyDown(key, keyText);
}

bool key_up(uint8 key, string& keyText)
{
	if(key == DIK_LMENU || key == DIK_RMENU) AltDown = false;
	if(key == DIK_LCONTROL || key == DIK_RCONTROL) CtrlDown = false;
	if(key == DIK_SPACE) SpaceDown=false;
	if( key == GetHotkey("zoom",DIK_Z) )
        __MapZooming = false;

	return GUI_KeyUp(key, keyText);
}

////////////////////////////////////////////////////////////////////////////////////////////////////
// Called on mouse/keyboard input lost (alt-tab, minimize, lost focus).
void input_lost()
{
	AltDown = false;
    __MapZooming = false;

	GUI_InputLost();
}

////////////////////////////////////////////////////////////////////////////////////////////////////
// Called on something critter in/out game.
void critter_in(CritterCl& cr)
{
	//Name prefixes
	for(uint i=0; i<PREFIXES.length(); i++)
	{
		if(cr.Name==PREFIXES[i][0] && cr.ParamBase[PLAYER_PREFIX]!=0) cr.Name="["+PREFIXES[i][1]+"] "+cr.Name;
	}
	/*
	if(PlayerDisplayType==PLAYER_DISPLAY_NAME) cr.NameOnHead="";
	else if(PlayerDisplayType==PLAYER_DISPLAY_FACTION) cr.NameOnHead=FACTIONS[cr.ParamBase[PLAYER_FACTION]];
	else if(PlayerDisplayType==PLAYER_DISPLAY_MAIN_FACTION)
	{
		if(cr.ParamBase[PLAYER_MAIN_FACTION]==0) cr.NameOnHead="no faction";
		else if(cr.ParamBase[PLAYER_MAIN_FACTION]==1) cr.NameOnHead="REF";
		else if(cr.ParamBase[PLAYER_MAIN_FACTION]==2) cr.NameOnHead="NEC";
	}
	*/
	bool AccessToDEVPanel=false;
	//string PlayerName=GetChosen().Name;
	if(true)
	{
		if(GetChosen().ParamBase[PLAYER_ACCESS] == ACCESS_ADMIN)
		{
			AccessToDEVPanel=true;
		}
	}
	if(AccessToDEVPanel)
	{
		DEVTextOpt.setVisible(true);
		DEVTextWorldMapOpt.setVisible(true);
	}
	else
	{
		DEVTextOpt.setVisible(false);
		DEVTextWorldMapOpt.setVisible(false);
	}

	// If the player entered the map, we refresh the factions
	if(cr.IsChosen()) {
		__InitializeFactions(0,0,0,null,null);
	}
	
	// Default colors
	cr.NameColor = COLOR_CRITTER_NAME;
	cr.ContourColor = (cr.IsPlayer() ? COLOR_CONTOUR_YELLOW : COLOR_CONTOUR_RED);

	// Try colorize from file
	if(TryColorizeCritter(cr)) return;

	// Karma voting
	cr.NameColor = COLOR_LIGHT(COLOR_CRITTER_NAME, cr.Stat[ST_PLAYER_KARMA] / 10);

	// Good / Evil system (not used)
	// Also see _GoodEvilListChanged in parameters.fos
	CritterCl@ chosen = GetChosen();
	if(cr.IsPlayer() && not cr.IsChosen() && valid(chosen))
	{
		int crId = int(cr.Id);
		for(uint i = GOOD_EVIL_LIST_BEGIN; i <= GOOD_EVIL_LIST_END; i++)
		{
			int id = chosen.GoodEvilList[i];
			bool isEvil = FLAG(id, 0x80000000);
			if(isEvil) id ^= 0x80000000;

			if(id == crId)
			{
				cr.NameColor = (isEvil ? COLOR_RED : COLOR_GREEN);
				cr.ContourColor = (isEvil ? COLOR_CONTOUR_RED : COLOR_CONTOUR_GREEN);
				break;
			}
		}
	}
}

void critter_out(CritterCl& cr)
{
}

////////////////////////////////////////////////////////////////////////////////////////////////////
// Called on something item in/changed/out map.
void item_map_in(ItemCl& item)
{
}

void item_map_changed(ItemCl& itemNow, ItemCl& itemBefore)
{
}

void item_map_out(ItemCl& item)
{
}

////////////////////////////////////////////////////////////////////////////////////////////////////
// Called on something critter in/out chosen inventory.
void item_inv_in(ItemCl& item)
{
}

void item_inv_out(ItemCl& item)
{
}

////////////////////////////////////////////////////////////////////////////////////////////////////
// Called on player drag&drop some item.
void item_drop(ItemCl& item)
{
}

////////////////////////////////////////////////////////////////////////////////////////////////////
// Call on receive message on map.
// By default delay == [TextDelay + message length * 100] ms
bool map_message(string& message, uint16& hexX, uint16& hexY, uint& color, uint& delay)
{
	// Detect radio
	if(color == 0xFFFFFFFE) message = ".." + message + "..";
	return true;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
// Call on receive message.
// By default delay == [TextDelay + message length * 100] ms
bool in_message(string& message, int& sayType, uint& critterId, uint& delay)
{
	CritterCl@ cr = GetCritter(critterId);
	if(sayType==SAY_SERVER_MESSAGE)
	{
		ServerMessageTextOpt.Text(message);
		ServerMessageTextOpt.setVisible(true);
		ServerMessageGlobalMapTextOpt.Text(message);
		ServerMessageGlobalMapTextOpt.setVisible(true);
		ServerMessageDissappearTime=__FullSecond+REAL_SECOND(20);
	}
	else if(sayType==SAY_SERVER_MESSAGE_TC)
	{
		TcServerMessageTextOpt.Text(message);
		TcServerMessageTextOpt.setVisible(true);
		TcServerMessageGlobalMapTextOpt.Text(message);
		TcServerMessageGlobalMapTextOpt.setVisible(true);
		TcServerMessageDissappearTime=__FullSecond+REAL_SECOND(60);
	}
	else if(sayType==SAY_SERVER_NOTE)
	{
		ServerMessageInfoRewardTextOpt.Text(message);
		ServerMessageInfoRewardTextOpt.setVisible(true);
		ServerNoteDissappearTime=__FullSecond+REAL_SECOND(10);
		
	}
	else if(sayType==SAY_SERVER_NOTE_2)
	{
		ServerMessageInfoRewardTextOpt.Text(message);
		ServerMessageInfoRewardTextOpt.setVisible(true);
		ServerNoteDissappearTime=__FullSecond+REAL_SECOND(3);
		
	}
	else if(sayType==SAY_KILLED_MSG)
	{
		ServerMessageInfoKilledTextOpt.Text(message);
		ServerMessageInfoKilledTextOpt.setVisible(true);
		ServerNoteDissappearTime=__FullSecond+REAL_SECOND(10);
	}
	else if(sayType==SAY_QUEST_PROGRESS)
	{
		UpdateQuestList(message);
	}
	else if(sayType==SAY_FACTION_INVITATION)
	{
		ShowFactionInvitationScreen(message);
	}
	else if(sayType==SAY_CHAT_MESSAGE)
	{
		ProcessChatMessage(message);
	}
	else if(sayType==SAY_COMBAT_INFORMATION && GetChosen().ParamBase[PLAYER_ACCESS] == ACCESS_ADMIN)
	{
		ProcessChatMessage(message);
	}
	
	if(valid(cr) && PlayerIgnored(cr)) return false;
	return true;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
// Call on send message.
bool out_message(string& message, int& sayType)
{
	if(message[0] == "~" || message[0] == "!") // Command
	{
		if(message == "~names")
		{
			InitNameColorizing();
			Message("Names colorizer refreshed.");
			return false;
		}

		if(message == "~faction" || message=="!faction")
		{
			ChangeCursor(0);
			ShowFactionScreen();
			return false;
		}
		
		if(message == "~bank" || message=="!bank")
		{
			ShowBankScreen(0,0,0,null,null);
			return false;
		}
		
		if(message.length() > 16)
		{
			if(substring(message, 0, 16) == "~server_message ")
			{
				string @str=substring(message,16,message.length()-16);
				RunServerScriptUnsafe("server_scripts@unsafe_server_message",0,0,0,str,null);
				return false;
			}
		}
		
		if(message.length() > 23)
		{
			if(substring(message, 0, 23) == "~set_red_exchange_rate ")
			{
				int exchangerate=0;
				StrToInt(substring(message,23,message.length()-23),exchangerate);
				RunServerScriptUnsafe("bank_server_scripts@unsafe_set_red_exchange_rate",exchangerate,0,0,null,null);
				return false;
			}
		}
		
		if(message.length() > 24)
		{
			if(substring(message, 0, 24) == "~set_blue_exchange_rate ")
			{
				int exchangerate=0;
				StrToInt(substring(message,24,message.length()-24),exchangerate);
				RunServerScriptUnsafe("bank_server_scripts@unsafe_set_blue_exchange_rate",exchangerate,0,0,null,null);
				return false;
			}
		}
		
		if(message == "~help")
		{
			Message("~changepassword oldpassword newpassword - change your password.");
			Message("~deleteself password - delete your account.");
			Message("~names - reload nicknames from NameColorizing.txt");
			Message("~ignorelist - reload ignore list from IgnoreList.txt");
			Message("~ignore nickname - add player to ignore list");
			Message("~faction - faction management screen");
			return false;
		}
		
		if(message == "~ignorelist")
		{
			InitIgnoreList();
			Message("Ignore List refreshed.");
			return false;
		}
		
		if(message == "~globalmap")
		{
			RunServerScriptUnsafe("nopvp_maps@unsafe_CritterToGlobal",0,0,0,null,null);
			return false;
		}
		
		if(message.length() > 8)
		{
			if(substring(message, 0, 8) == "~ignore ")
			{
				IgnorePlayer(message);
				InitIgnoreList();
				return false;
			}
		}
		
		if(message == "~chat" || message=="!chat")
		{
			ChangeCursor(0);
			ShowChatScreen();
			return false;
		}
		
		if(message == "~quest" || message=="!quest")
		{
			RunServerScriptUnsafe("quest_server_scripts@unsafe_GetQuestProgress",0,0,0,null,null);
			return false;
		}
		
		if((message == "~event" || message=="!event") && GetChosen().ParamBase[PLAYER_ACCESS] == ACCESS_ADMIN)
		{
			ChangeCursor(0);
			ShowScreen(CLIENT_SCREEN_EVENT_PANEL,0,0,0);
			return false;
		}
		
		if((message == "~eventb" || message=="!eventb") && GetChosen().ParamBase[PLAYER_ACCESS] == ACCESS_ADMIN)
		{
			ChangeCursor(0);
			ShowScreen(CLIENT_SCREEN_EVENT_B_PANEL,0,0,0);
			return false;
		}
		
		if(message == "~test1")
		{
			AddQuestNotification("Quest done","Just a dream","It's time for a quick move. I have much work to do.");
			return false;
		}
		
		if(message == "~weapons")
		{
			RunServerScriptUnsafe("dev_server_scripts@unsafe_GiveWeapons",0,0,0,null,null);
			return false;
		}
		
		if(message == "~ammo")
		{
			RunServerScriptUnsafe("dev_server_scripts@unsafe_GiveAmmo",0,0,0,null,null);
			return false;
		}		
		
		if(message == "~test3")
		{
			FlushScreen(0x30DD1111,0,500);
			return false;
		}
		
		if(message == "~test4")
		{
			return false;
		}
		
		if(message == "~test5")
		{
			RunServerScriptUnsafe("dev_server_scripts@unsafe_Lightning",0,0,0,null,null);
			return false;
		}
		
		if(message == "~test6")
		{
			IsSnowing=!IsSnowing;
			return false;
		}
		
		if(message == "~test7")
		{
			RunServerScriptUnsafe("dev_server_scripts@unsafe_SmallRain",0,0,0,null,null);
			return false;
		}
		
		if(message == "~test8")
		{
			RunServerScriptUnsafe("dev_server_scripts@unsafe_BigRain",0,0,0,null,null);
			return false;
		}
		
		if(message == "~test9")
		{
			RunServerScriptUnsafe("dev_server_scripts@unsafe_NoRain",0,0,0,null,null);
			return false;
		}
		if(message == "~ntactic")
		{
			RunServerScriptUnsafe("tactic@unsafe_tactic_normal",0,0,0,null,null);
			return false;
		}
		if(message == "~atactic")
		{
			RunServerScriptUnsafe("tactic@unsafe_tactic_agressive",0,0,0,null,null);
			return false;
		}
		if(message == "~dtactic")
		{
			RunServerScriptUnsafe("tactic@unsafe_tactic_defensive",0,0,0,null,null);
			return false;
		}
		if(message == "~changeturnbase")
		{
			RunServerScriptUnsafe("dev_server_scripts@unsafe_ChangeTurnBaseInMap",0,0,0,null,null);
			return false;
		}
		if(message == "~deletelocation")
		{
			RunServerScriptUnsafe("dev_server_scripts@unsafe_DeleteLocation",0,0,0,null,null);
			return false;
		}
		if(message == "~setknowloc")
		{
			RunServerScriptUnsafe("dev_server_scripts@unsafe_SetKnowLocation",0,0,0,null,null);
			return false;
		}
		if(message == "~usetknowloc")
		{
			RunServerScriptUnsafe("dev_server_scripts@unsafe_USetKnowLocation",0,0,0,null,null);
			return false;
		}
		if(message == "~teleport")
		{
			RunServerScriptUnsafe("dev_server_scripts@unsafe_TeleportToMap",GetChosen().Id,666,0,null,null);
			return false;
		}
		return true;
	}

	if(sayType == SAY_NORM)
	{
		if(message.length() > 2 && (message[0] == "/" || message[0] == "."))
		{
			int eraseCount = 1;
			string ch = message[ 1 ];
            if(     ch == "к" || ch == "К" || ch == "s" || ch == "S" )
                sayType = SAY_SHOUT;
            else if( ch == "э" || ch == "Э" || ch == "e" || ch == "E" )
                sayType = SAY_EMOTE;
            else if( ch == "ш" || ch == "Ш" || ch == "w" || ch == "W" )
                sayType = SAY_WHISP;
            else if( ch == "с" || ch == "С" || ch == "$" )
                sayType = SAY_SOCIAL;
            else if( ch == "р" || ch == "Р" || ch == "r" || ch == "R" )
                sayType = SAY_RADIO;

			if(sayType != SAY_NORM)
			{
				eraseCount++;
				if(message[2] == " ") eraseCount++;
			}

			message = substring(message, eraseCount, message.length() - eraseCount);
		}
		else if( // RegExp: [*]([^*].*[^*])[*]
			message.length() >= 4 && message[0] == "*" && message[1] != "*" &&
			message[message.length() - 2] != "*" && message[message.length() - 1] == "*")
		{
			sayType = SAY_EMOTE;
			message = substring(message, 1, message.length() - 2);
		}
	}

	bool result = false;
	for(uint i = 0, j = message.length(); i < j; i++)
	{
		if(message[i] != " ")
		{
			result = true;
			break;
		}
	}

	return result;
}

void AddQuestNotificationMsgStr(int quest, int progress, int, string@ title, int[]@)
{
	if(progress==100) AddQuestNotification(title,QUESTS[quest],GetMsgStr(TEXTMSG_QUEST,STR_QUEST_FINISCH));
	else AddQuestNotification(title,QUESTS[quest],GetMsgStr(TEXTMSG_QUEST,20000000+quest*100+progress));
}

////////////////////////////////////////////////////////////////////////////////////////////////////
// To-hit chance.
int to_hit(CritterCl& chosen, CritterCl& target, ProtoItem& weapon, uint8 weaponMode)
{
	int use         = _WeaponModeUse(weaponMode);
	int hitLocation = _WeaponModeAim(weaponMode);
	if(use > 2) return 0;

    if(target.IsDead()) return 0;
    if(!chosen.IsLife()) return 0;

    ItemCl@ realWeapon = _CritGetItemHand(chosen);
    ProtoItem@ ammo = null;

    if(valid(realWeapon) && _WeaponRound(weapon, use) > 0)
    {
        if(realWeapon.AmmoCount == 0) return 0;
        @ammo=GetProtoItem(realWeapon.AmmoPid);
    }

    uint skillNum = _WeaponSkill(weapon, use);
    int wpnMaxDist = _WeaponMaxDist(weapon, use);
    if(skillNum == SK_THROWING) wpnMaxDist = MIN(wpnMaxDist, 3 * MIN(int(10), chosen.Stat[ST_STRENGTH]));

    int dist = GetCrittersDistantion(chosen, target);
    if(dist > wpnMaxDist) return 0;

    int toHit = int(chosen.Skill[skillNum]);
    int weaponPerk = weapon.Weapon_Perk;
    int blockers = 0;

    if(skillNum != SK_UNARMED)
    {
        // Ranged attack modifiers
        int distmod1 = 2; // Used for initial weapon bonus
        int distmod2 = 0; // Minimal distance
        if(weaponPerk == WEAPON_PERK_LONG_RANGE) distmod1 = 4;
        else if(weaponPerk == WEAPON_PERK_SCOPE_RANGE)
        {
            distmod1 = 5;
            distmod2 = 8;
        }

        int perception = chosen.Stat[ST_PERCEPTION];
        int acc = dist;

        if(dist < distmod2) acc += distmod2;
        else
        {
            if(chosen.IsPlayer())
				acc -= (perception - 2) * distmod1; // we want to keep it, because fo2238 might use it to display NPCs chance (via possessing)
            else
				acc -= perception * distmod1;
        }

        if(-2 * perception > acc) acc = -2 * perception;

        if(acc >= 0)
        {
            if(chosen.Damage[DAMAGE_EYE]!=0)
				acc *= -12;
            else
				acc *= -4;
        }
        else acc *= -4;

        toHit += acc;

        blockers = GetCrittersPath(chosen.HexX, chosen.HexY, target.HexX, target.HexY, 0.0f, dist, FIND_LIFE, null);
        if(!target.IsKnockout()) blockers--;
        toHit -= 10 * blockers;
    } // End range modifiers

    if(!(weapon.Weapon_IsUnarmed) && chosen.Trait[TRAIT_ONE_HANDER] != 0 && valid(realWeapon))
        toHit += (FLAG(weapon.Flags, ITEM_TWO_HANDS) ? -40 : 20);

    int handlingStrength = chosen.Stat[ST_STRENGTH];
    int reqStrength = weapon.Weapon_MinStrength;
    if(handlingStrength < reqStrength) toHit -= (reqStrength - handlingStrength) * 20;
    if(weaponPerk == WEAPON_PERK_ACCURATE) toHit += 20;

    int acmod = target.Stat[ST_ARMOR_CLASS];
    if(valid(ammo)) acmod += ammo.Ammo_ACMod;
    if(acmod > 0) toHit -= acmod;
    // TODO: tohit += 15 if target is multihex
    // TODO: light penalty

    if(chosen.Damage[DAMAGE_EYE] != 0) toHit -= 25;;
    if(target.IsKnockout()) toHit += 40;
    toHit += target.GetMultihex() * 15;

    int hitMod = GetHitAim(hitLocation);
    if(skillNum == SK_UNARMED) hitMod /= 2;
    toHit -= hitMod;
    toHit = CLAMP(toHit, 5, 95);

    return toHit;
}

uint GetHitAim(int hitLocation)
{
	switch(hitLocation)
	{
	case HIT_LOCATION_NONE:      break;
	case HIT_LOCATION_UNCALLED:  break;
	case HIT_LOCATION_TORSO:     return __HitAimTorso;
	case HIT_LOCATION_EYES:      return __HitAimEyes;
	case HIT_LOCATION_HEAD:      return __HitAimHead;
	case HIT_LOCATION_LEFT_ARM:
	case HIT_LOCATION_RIGHT_ARM: return __HitAimArms;
	case HIT_LOCATION_GROIN:     return __HitAimGroin;
	case HIT_LOCATION_RIGHT_LEG:
	case HIT_LOCATION_LEFT_LEG:  return __HitAimLegs;
	default: break;
	}
	return 0;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
// Override aim location set by player through targetting screen or simple click on target.
void hit_aim(uint8& aim)
{
	if(GetAutoAimHitLocation()!=HIT_LOCATION_NONE) aim=GetAutoAimHitLocation();
}

////////////////////////////////////////////////////////////////////////////////////////////////////
// Combat results.
void combat_result(uint[]& data)
{
	uint datalen = data.length();
	if(datalen == 0) return;
	if(data[0] != datalen) return;

	uint current = 1;

	while(current < datalen)
	{
		int damage  = -1;
		uint effect =  0;
		uint loc    =  0;
		int message = -1;

		uint mode = data[current++];
		uint who  = data[current++];
		uint who2;
		CritterCl@ originalTarget;

		CritterCl@ cr         = GetCritter(who);
		CritterCl@ chosen     = GetChosen();
		CritterCl@ trueTarget = null;

		bool self = (who == GetChosen().Id);

		string name = "error0";
		if(valid(cr))
		{
			if(!self)
				name = cr.Name;
			else
				name = GetMsgStr(TEXTMSG_COMBAT, chosen.Stat[ST_GENDER] == GENDER_MALE ? 506 : 556);
		}

		uint offset;
		if(self)
		{
			if(cr.Stat[ST_GENDER] == GENDER_MALE)
				offset = 506;
			else
				offset = 556;
		}
		else
		{
			if(cr.Stat[ST_GENDER] == GENDER_MALE)
				offset = 606;
			else
				offset = 706;
		}

		string result;

		// reading and preparing the data:
		switch(mode)
		{
		case CMSG_CRIT_MISS:
			effect = data[current++];
			result = GetMsgStr(TEXTMSG_COMBAT, offset + 8);
			result = ReplaceText(result, "%s", name);
			break;
		case CMSG_CRIT_MISS_DAMAGE:
			effect = data[current++];
			damage = data[current++];
			result = GetMsgStr(TEXTMSG_COMBAT, offset + (damage > 1 ? 28 : 27));
			result = ReplaceText(result, "%s", name);
			if(damage > 1) result = ReplaceText(result, "%d", damage);
			break;
		case CMSG_HIT:
		case CMSG_HIT_DEAD:
			damage = data[current++];
			result = GetMsgStr(TEXTMSG_COMBAT, offset + (damage > 1 ? 7 : (damage != 0 ? 17 : 21)));
			result = ReplaceText(result, "%s", name);
			if(damage > 1) result = ReplaceText(result, "%d", damage);
			break;
		case CMSG_AIMED_HIT:
		case CMSG_AIMED_HIT_DEAD:
			loc    = data[current++];
			damage = data[current++];
			result = GetMsgStr(TEXTMSG_COMBAT, offset + (damage > 1 ? 6 : (damage !=0 ? 16 : 20)));
			result = ReplaceText(result, "%s", name);
			result = ReplaceText(result, "%s", GetMsgStr(TEXTMSG_COMBAT, 1000 + cr.CrTypeAlias * 10 + loc - 1));
			if(damage > 1) result = ReplaceText(result, "%d", damage);
			break;
		case CMSG_CRIT_HIT:
			damage  = data[current++];
			effect  = data[current++];
			message = data[current++];
			result = GetMsgStr(TEXTMSG_COMBAT, offset + (damage > 1 ? 14 : (damage != 0 ? 18 : 22)));
			result = ReplaceText(result, "%s", name);
			if(damage > 1) result = ReplaceText(result, "%d", damage);
			break;
		case CMSG_CRIT_AIMED_HIT:
			loc     = data[current++];
			damage  = data[current++];
			effect  = data[current++];
			message = data[current++];
			result = GetMsgStr(TEXTMSG_COMBAT, offset + (damage > 1 ? 5 : (damage != 0 ? 15 : 19)));
			result = ReplaceText(result, "%s", name);
			result = ReplaceText(result, "%s", GetMsgStr(TEXTMSG_COMBAT, 1000 + cr.CrTypeAlias * 10 + loc - 1));
			if(damage > 1) result = ReplaceText(result, "%d", damage);
			break;
		case CMSG_CRIT_HIT_DEAD:
			damage  = data[current++];
			message = data[current++];
			result = GetMsgStr(TEXTMSG_COMBAT, offset + (damage > 1 ? 14 : (damage != 0 ? 18 : 22)));
			result = ReplaceText(result, "%s", name);
			if(damage > 1) result = ReplaceText(result, "%d", damage);
			break;
		case CMSG_CRIT_AIMED_HIT_DEAD:
			loc     = data[current++];
			damage  = data[current++];
			message = data[current++];
			result = GetMsgStr(TEXTMSG_COMBAT, offset + (damage > 1 ? 5 : (damage != 0 ? 15 : 19)));
			result = ReplaceText(result, "%s", name);
			result = ReplaceText(result, "%s", GetMsgStr(TEXTMSG_COMBAT, 1000 + cr.CrTypeAlias * 10 + loc - 1));
			if(damage > 1) result = ReplaceText(result, "%d", damage);
			break;
		case CMSG_OOPS:
			who2 = data[current++]; // who2 was hit instead of who
			// +2 "... was hit instead of you!"
			// +3 "... was hit instead of ...!"
			@trueTarget = GetCritter(who2);
			if(self)
			{
				// It was original target
				result += 
				result = GetMsgStr(TEXTMSG_COMBAT, cr.Stat[ST_GENDER] == GENDER_MALE ? 608 : 708);
				string nameTrue = "error1";
				if(valid(trueTarget)) nameTrue = trueTarget.Name;
				result = ReplaceText(result, "%s", nameTrue);
			}
			else
			{
				// It was not original target
				result = GetMsgStr(TEXTMSG_COMBAT,offset+3);
				if(who2 == GetChosen().Id)
				{
					result = ReplaceText(result, "%s", GetMsgStr(TEXTMSG_COMBAT, chosen.Stat[ST_GENDER] == GENDER_MALE ? 506 : 556));
				}
				else
				{
					string nameTrue = "error1";
					if(valid(trueTarget)) nameTrue = trueTarget.Name;
					result = ReplaceText(result, "%s", nameTrue);
				}
				result = ReplaceText(result, "%s", name);
			}
			break;
		case CMSG_MISS:
			result = GetMsgStr(TEXTMSG_COMBAT, offset + 9);
			result = ReplaceText(result, "%s", name);
			break;
		case CMSG_HIT_RANDOMLY:
			result  = GetMsgStr(TEXTMSG_COMBAT, offset + 9);
			result  = ReplaceText(result, "%s", name);
			result += GetMsgStr(TEXTMSG_COMBAT, 108) + GetMsgStr(TEXTMSG_COMBAT, offset - 306 + 20);
		default:
			break;
		}

		bool isVerbose = (__CombatMessagesType == 0);
		string@[] ext;

		if(message != -1 && isVerbose) // Must be critical hit
		{
			result += GetMsgStr(TEXTMSG_COMBAT, message);
		}
		else if(effect!=0)
		{
			offset -= 306;
			if(mode > CMSG_CRIT_MISS_DAMAGE) // Hit flags
			{
				if(FLAG(effect, HF_KNOCKOUT))           ext.insertLast(@GetMsgStr(TEXTMSG_COMBAT, offset + 0 ));
				if(FLAG(effect, HF_KNOCKDOWN))          ext.insertLast(@GetMsgStr(TEXTMSG_COMBAT, offset + 1 ));
				if(FLAG(effect, HF_CRIPPLED_LEFT_LEG))  ext.insertLast(@GetMsgStr(TEXTMSG_COMBAT, offset + 2 ));
				if(FLAG(effect, HF_CRIPPLED_RIGHT_LEG)) ext.insertLast(@GetMsgStr(TEXTMSG_COMBAT, offset + 3 ));
				if(FLAG(effect, HF_CRIPPLED_LEFT_ARM))  ext.insertLast(@GetMsgStr(TEXTMSG_COMBAT, offset + 4 ));
				if(FLAG(effect, HF_CRIPPLED_RIGHT_ARM)) ext.insertLast(@GetMsgStr(TEXTMSG_COMBAT, offset + 5 ));
				if(FLAG(effect, HF_BLINDED))            ext.insertLast(@GetMsgStr(TEXTMSG_COMBAT, offset + 6 ));
				// if(FLAG(effect, HF_DEATH))              ext.insertLast(@GetMsgStr(TEXTMSG_COMBAT, offset     )); // This is handled elsewhere
				// if(FLAG(effect, HF_ON_FIRE))            ext.insertLast(@GetMsgStr(TEXTMSG_COMBAT, offset + 10)); // Not used
				if(FLAG(effect, HF_BYPASS_ARMOR))       ext.insertLast(@GetMsgStr(TEXTMSG_COMBAT, offset + 11));
				if(FLAG(effect, HF_DROPPED_WEAPON))     ext.insertLast(@GetMsgStr(TEXTMSG_COMBAT, offset + 14));
				if(FLAG(effect, HF_LOST_NEXT_TURN))     ext.insertLast(@GetMsgStr(TEXTMSG_COMBAT, offset + 15));
				if(FLAG(effect, HF_RANDOM))             ext.insertLast(@GetMsgStr(TEXTMSG_COMBAT, offset + 21));
			}
			else
			{
				if(FLAG(effect, MF_KNOCKED_DOWN))         ext.insertLast(@GetMsgStr(TEXTMSG_COMBAT, offset +  1));
				// if(FLAG(effect, MF_ON_FIRE))              ext.insertLast(@GetMsgStr(TEXTMSG_COMBAT, offset + 10)); // Not used
				if(FLAG(effect, MF_WEAPON_EXPLODED))      ext.insertLast(@GetMsgStr(TEXTMSG_COMBAT, offset + 12));
				if(FLAG(effect, MF_WEAPON_DESTROYED))     ext.insertLast(@GetMsgStr(TEXTMSG_COMBAT, offset + 13));
				if(FLAG(effect, MF_WEAPON_DROPPED))       ext.insertLast(@GetMsgStr(TEXTMSG_COMBAT, offset + 14));
				if(FLAG(effect, MF_LOST_NEXT_TURN))       ext.insertLast(@GetMsgStr(TEXTMSG_COMBAT, offset + 15));
				if(FLAG(effect, MF_HIT_SELF))             ext.insertLast(@GetMsgStr(TEXTMSG_COMBAT, offset + 16));
				if(FLAG(effect, MF_LOST_REST_OF_AMMO))    ext.insertLast(@GetMsgStr(TEXTMSG_COMBAT, offset + 17));
				if(FLAG(effect, MF_FIRED_DUD_SHOT))       ext.insertLast(@GetMsgStr(TEXTMSG_COMBAT, offset + 18));
				if(FLAG(effect, MF_HURT_SELF))            ext.insertLast(@GetMsgStr(TEXTMSG_COMBAT, offset + 19));
				// if(FLAG(effect, MF_HIT_RANDOMLY))         ext.insertLast(@GetMsgStr(TEXTMSG_COMBAT, offset + 20)); // This is handled elsewhere
				if(FLAG(effect, MF_CRIPPLED_RANDOM_LIMB)) ext.insertLast(@GetMsgStr(TEXTMSG_COMBAT, offset + 21));
				if(FLAG(effect, MF_WAS_KILLED))           ext.insertLast(@GetMsgStr(TEXTMSG_COMBAT, offset +  7));
			}
			offset += 306;
		}

		if(8 <= mode && mode <= 11 && (!isVerbose || message==-1 || message != -1))
			ext.insertLast(@GetMsgStr(TEXTMSG_COMBAT, offset + 7 - 306));

		for(uint m = 0, n = ext.length(); m < n; m++)
		{
			if(m == n - 1)
				result += GetMsgStr(TEXTMSG_COMBAT, 108);
			else
				result += ", ";

			result += ext[m];
		}

		result += ".";

		uint colorRed = COLOR_RGB(240, 0, 0); //color for colored message
		if (ColoredCombatMSG == false)
		{
		Message(result, FOMB_COMBAT_RESULT);
		}
		else if (ColoredCombatMSG == true && self) Message( "|" + colorRed + " " + result, FOMB_COMBAT_RESULT); //colored message in log if chosen is damaged
		else if (ColoredCombatMSG == true && !self) Message(result, FOMB_COMBAT_RESULT);
		

		// On head indication
		if(__DamageHitDelay > 0 && damage > 0)
			MapMessage("-" + damage, cr.HexX, cr.HexY, __DamageHitDelay, 0xFFC80000, true, Random(-5, 5), -20);
	}
}

////////////////////////////////////////////////////////////////////////////////////////////////////
// Generic description. Descriptions type look in _client_defines.fos, Generic descriptions types.
// int& offsX, int& offsY - offsets of text, by default is zero.
string generic_description(int descType, int& offsX, int& offsY)
{
	CritterCl@ chosen = GetChosen();
	if(not valid(chosen)) return "";
	string result;

	if(descType == DESC_INVENTORY_MAIN)
	{
		result += chosen.Name        + "\n";
		result += "---------------------\n";
		result += GetMsgStr(TEXTMSG_GAME, STR_INV_SHORT_SPECIAL(ST_STRENGTH))   + "\n";
		result += GetMsgStr(TEXTMSG_GAME, STR_INV_SHORT_SPECIAL(ST_PERCEPTION)) + "\n";
		result += GetMsgStr(TEXTMSG_GAME, STR_INV_SHORT_SPECIAL(ST_ENDURANCE))  + "\n";
		result += GetMsgStr(TEXTMSG_GAME, STR_INV_SHORT_SPECIAL(ST_CHARISMA))   + "\n";
		result += GetMsgStr(TEXTMSG_GAME, STR_INV_SHORT_SPECIAL(ST_INTELLECT))  + "\n";
		result += GetMsgStr(TEXTMSG_GAME, STR_INV_SHORT_SPECIAL(ST_AGILITY))    + "\n";
		result += GetMsgStr(TEXTMSG_GAME, STR_INV_SHORT_SPECIAL(ST_LUCK))       + "\n";
		result += "---------------------\n";

		ItemCl@ weaponMain = chosen.GetItem(0, SLOT_HAND1);
		if(valid(weaponMain))
		{
			int use = _WeaponModeUse(weaponMain.Mode);
			if(use > 2) use = 0;

			result += GetMsgStr(TEXTMSG_ITEM, STR_ITEM_INFO(weaponMain)) + "\n";

			if(weaponMain.GetType() == ITEM_TYPE_WEAPON)
			{
				result += GetMsgStr(TEXTMSG_GAME, STR_INV_DMG) + " ";
				result += _WeaponDmgMin(weaponMain.Proto, use) + "-";
				int wpnMaxDmg = _WeaponDmgMax(weaponMain.Proto, use);
				if(_WeaponIsHtHAttack(weaponMain.Proto, use)) wpnMaxDmg += chosen.Stat[ST_MELEE_DAMAGE];
				result += wpnMaxDmg;

				if(_WeaponMaxDist(weaponMain.Proto, use) > 1)
				{
					result += " " + GetMsgStr(TEXTMSG_GAME, STR_INV_DIST) + " ";
					int wpnMaxDist = _WeaponMaxDist(weaponMain.Proto, use);
					if(_WeaponSkill(weaponMain.Proto, use) == SK_THROWING)
						wpnMaxDist = MIN(wpnMaxDist, 3 * MIN(int(10), chosen.Stat[ST_STRENGTH]));
					result += wpnMaxDist;
				}
				result += "\n";

				if(weaponMain.Proto.Weapon_MaxAmmoCount > 0)
				{
					result += GetMsgStr(TEXTMSG_GAME, STR_INV_AMMO) + " ";
					result += weaponMain.AmmoCount            + "/";
					result += weaponMain.Proto.Weapon_MaxAmmoCount  + " ";
					result += GetMsgStr(TEXTMSG_GAME, STR_CALIBER(weaponMain.Proto.Weapon_Caliber));
				}
				result += "\n";
			}
			else
			{
				result += "\n\n";
			}
		}
		else
		{
			// Unarmed
			uint8 mode = 0;
			ProtoItem@ unarmed = chosen.GetSlotProto(SLOT_HAND1, mode);
			result += GetMsgStr(TEXTMSG_GAME, STR_INV_NO_ITEM)     + "\n";
			result += GetMsgStr(TEXTMSG_GAME, STR_INV_UNARMED_DMG) + " ";
			result += _WeaponDmgMin(unarmed, _WeaponModeUse(mode)) + "-";
			result += (_WeaponDmgMax(unarmed, _WeaponModeUse(mode)) + chosen.Stat[ST_MELEE_DAMAGE]);
			result += "\n\n";
		}
		result += "---------------------\n";

		ItemCl@ weaponExt = chosen.GetItem(0, SLOT_HAND2);
		if(valid(weaponExt))
		{
			int use = _WeaponModeUse(weaponExt.Mode);
			if(use > 2) use = 0;

			result += GetMsgStr(TEXTMSG_ITEM, STR_ITEM_INFO(weaponExt)) + "\n";

			if(weaponExt.GetType() == ITEM_TYPE_WEAPON)
			{
				result += GetMsgStr(TEXTMSG_GAME, STR_INV_DMG) + " ";
				result += _WeaponDmgMin(weaponExt.Proto, use)  + "-";
				int wpnMaxDmg = _WeaponDmgMax(weaponExt.Proto, use);
				if(_WeaponIsHtHAttack(weaponExt.Proto, use)) wpnMaxDmg += chosen.Stat[ST_MELEE_DAMAGE];
				result += wpnMaxDmg;
				if(_WeaponMaxDist(weaponExt.Proto, use) > 1)
				{
					result += " " + GetMsgStr(TEXTMSG_GAME, STR_INV_DIST) + " ";
					int wpnMaxDist = _WeaponMaxDist(weaponExt.Proto, use);
					if(_WeaponSkill(weaponExt.Proto, use) == SK_THROWING)
						wpnMaxDist = MIN(wpnMaxDist, 3 * MIN(int(10), chosen.Stat[ST_STRENGTH]));
					result += wpnMaxDist;
				}
				result += "\n";

				if(weaponExt.Proto.Weapon_MaxAmmoCount > 0)
				{
					result += GetMsgStr(TEXTMSG_GAME, STR_INV_AMMO) + " ";
					result += weaponExt.AmmoCount             + "/";
					result += weaponExt.Proto.Weapon_MaxAmmoCount   + " ";
					result += GetMsgStr(TEXTMSG_GAME, STR_CALIBER(weaponExt.Proto.Weapon_Caliber));
				}
				result += "\n";
			}
			else
			{
				result += "\n\n";
			}
		}
		else
		{
			// Unarmed
			uint8 mode = 0;
			ProtoItem@ unarmed = chosen.GetSlotProto(SLOT_HAND2, mode);
			result += GetMsgStr(TEXTMSG_GAME, STR_INV_NO_ITEM)     + "\n";
			result += GetMsgStr(TEXTMSG_GAME, STR_INV_UNARMED_DMG) + " ";
			result += _WeaponDmgMin(unarmed, _WeaponModeUse(mode)) + "-";
			result += (_WeaponDmgMax(unarmed, _WeaponModeUse(mode)) + chosen.Stat[ST_MELEE_DAMAGE]);
			result += "\n\n";
		}

		result += GetMsgStr(TEXTMSG_GAME, STR_INV_TOTAL_WEIGHT) + " ";
		result += (chosen.ItemsWeight() / 1000) + "/";
		result += (chosen.Stat[ST_CARRY_WEIGHT] / 1000) + ".";
	}
	else if(descType == DESC_INVENTORY_SPECIAL)
	{
		offsX = 23;
		result += "\n\n";
		result += chosen.Stat[ST_STRENGTH]   + "\n";
		result += chosen.Stat[ST_PERCEPTION] + "\n";
		result += chosen.Stat[ST_ENDURANCE]  + "\n";
		result += chosen.Stat[ST_CHARISMA]   + "\n";
		result += chosen.Stat[ST_INTELLECT]  + "\n";
		result += chosen.Stat[ST_AGILITY]    + "\n";
		result += chosen.Stat[ST_LUCK];
	}
	else if(descType==DESC_INVENTORY_STATS)
	{
		offsX=39;
		result += "\n\n";
		result += GetMsgStr(TEXTMSG_GAME, STR_INV_HP) + " ";
		result += chosen.Stat[ST_CURRENT_HP] + "/" + chosen.Stat[ST_MAX_LIFE] + "\n";
		result += GetMsgStr(TEXTMSG_GAME, STR_INV_AC) + " ";
		result += chosen.Stat[ST_ARMOR_CLASS] + "\n";
		result += GetMsgStr(TEXTMSG_GAME, STR_INV_NORMAL) + "\n";
		result += GetMsgStr(TEXTMSG_GAME, STR_INV_LASER)  + "\n";
		result += GetMsgStr(TEXTMSG_GAME, STR_INV_FIRE)   + "\n";
		result += GetMsgStr(TEXTMSG_GAME, STR_INV_PLASMA) + "\n";
		result += GetMsgStr(TEXTMSG_GAME, STR_INV_EXPLODE);
	}
	else if(descType==DESC_INVENTORY_RESIST)
	{
		offsX=103;
		result += "\n\n\n\n";
		result += chosen.Stat[ST_NORMAL_ABSORB]  + "/" + chosen.Stat[ST_NORMAL_RESIST]  + "%\n";
		result += chosen.Stat[ST_LASER_ABSORB]   + "/" + chosen.Stat[ST_LASER_RESIST]   + "%\n";
		result += chosen.Stat[ST_FIRE_ABSORB]    + "/" + chosen.Stat[ST_FIRE_RESIST]    + "%\n";
		result += chosen.Stat[ST_PLASMA_ABSORB]  + "/" + chosen.Stat[ST_PLASMA_RESIST]  + "%\n";
		result += chosen.Stat[ST_EXPLODE_ABSORB] + "/" + chosen.Stat[ST_EXPLODE_RESIST] + "%";
	}

	return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
// Item description. Look types look in _client_defines.fos, Item look types.
string item_description(ItemCl& item, int lookType)
{
	// Default error text
	if(not IsMsgStr(TEXTMSG_ITEM, STR_ITEM_INFO(item) + (lookType != ITEM_LOOK_ONLY_NAME ? 1 : 0))) 
		return GetMsgStr(TEXTMSG_GAME, STR_ITEM_LOOK_NOTHING);

	string result;

	// Car on world map
	if(lookType == ITEM_LOOK_WM_CAR)
	{
		string fuel = GetMsgStr(TEXTMSG_GAME, STR_INV_CAR_FUEL);
		fuel = ReplaceText(fuel, "VALUE",     item.Charge / 100);
		fuel = ReplaceText(fuel, "MAX_VALUE", item.Proto.Car_TankVolume / 100);
		string deterioration = GetMsgStr(TEXTMSG_GAME, STR_INV_CAR_DETERIORATION);
		deterioration = ReplaceText(deterioration, "VALUE", item.Deterioration * 100 / item.Proto.Car_MaxDeterioration);
		result = fuel + "\n" + deterioration;
	}
	// Short info
	else if(lookType == ITEM_LOOK_ONLY_NAME)
	{
		result += ReplaceText(GetMsgStr(TEXTMSG_GAME, STR_ITEM_LOOK), "NAME", GetMsgStr(TEXTMSG_ITEM, STR_ITEM_INFO(item)));
	}
	// Full info
	else
	{
			CritterCl@ chosen = GetChosen();
			if(not valid(chosen)) return "";
			uint colorGreen = COLOR_RGB(60, 248, 0); //Зелёный
			uint colorYellow = COLOR_RGB(255, 255, 0); //Жёлтый
			uint colorPink = COLOR_RGB(255, 128, 255); //Розовый
			uint colorOrange = COLOR_RGB(255, 128, 0); //Оранжевый
			uint colorRed = COLOR_RGB(255, 0, 0); //Красный
			uint colorTurquoise = COLOR_RGB(0, 255, 255); //Бирюзовый
			// result += "|" + colorGreen + " ";
		
		if(lookType == ITEM_LOOK_INVENTORY)
		{
			if(item.Proto.Weapon_Perk1 >0 && item.Proto.Weapon_Perk2 >0 && item.Proto.Weapon_Perk3 >0 && item.Proto.Weapon_Perk4 >0 && item.Proto.Weapon_Perk5 >0 && item.Proto.Weapon_Perk6 >0)
			{
				if(item.Val5 >= 1000 && item.Val5 <= 1999)
				{					
					result += "[1] ";
				}
				if(item.Val5 >= 2000 && item.Val5 <= 2999)
				{			
					result += "|" + colorYellow + " ";
					result += "[2] ";
				}
				if(item.Val5 >= 3000 && item.Val5 <= 3999)
				{	
					result += "|" + colorPink + " ";
					result += "[3] ";
				}
				if(item.Val5 >= 4000 && item.Val5 <= 4999)
				{	
					result += "|" + colorOrange + " ";
					result += "[4] ";
				}
				if(item.Val5 >= 5000 && item.Val5 <= 5999)
				{	
					result += "|" + colorRed + " ";
					result += "[5] ";
				}
				if(item.Val5 >= 6000)
				{	
					result += "|" + colorTurquoise + " ";
					result += "[6] ";
				}
			}
			result += GetMsgStr(TEXTMSG_ITEM, STR_ITEM_INFO(item)) + "\n";
			result += "|" + colorGreen + " ";
		}
		
		if(item.GetProtoId() == PID_HOLODISK && item.HolodiskNumber != 0)
			result += GetMsgStr(TEXTMSG_HOLO, STR_HOLO_INFO_NAME(item.HolodiskNumber));
		else
			result += GetMsgStr(TEXTMSG_ITEM, STR_ITEM_INFO(item) + 1);

		if(lookType != ITEM_LOOK_MAP)
		{
			// Strengh required to handle weapon
			if(item.GetType() == ITEM_TYPE_WEAPON)
			{
				result += "\n";
				string str = GetMsgStr(TEXTMSG_GAME, STR_INV_WEAPON_MIN_STRENGTH);
				str = ReplaceText(str,"VALUE",     item.Proto.Weapon_MinStrength);
				result += str;
			}
			
			// Weight
			result += "\n" + ReplaceText(GetMsgStr(TEXTMSG_GAME, STR_ITEM_WEIGHT_GRAMM), "VALUE", item.Proto.Weight * item.GetCount());
			
			// Deterioration
			if(item.IsDeteriorable())
			{
				uint8 brokenFlags    = item.BrokenFlags;
				uint8 brokenCount    = item.BrokenCount;
				uint16 deterioration = item.Deterioration;

				// Broken level, procent
				result += "\n";
				if(FLAG(brokenFlags,BI_NOTRESC))         result += GetMsgStr(TEXTMSG_GAME, STR_DETERIORATION_NO_RESC);
				else if(FLAG(brokenFlags,BI_LOWBROKEN))  result += GetMsgStr(TEXTMSG_GAME, STR_DETERIORATION_BROKEN_LOW);
				else if(FLAG(brokenFlags,BI_NORMBROKEN)) result += GetMsgStr(TEXTMSG_GAME, STR_DETERIORATION_BROKEN_NORM);
				else if(FLAG(brokenFlags,BI_HIGHBROKEN)) result += GetMsgStr(TEXTMSG_GAME, STR_DETERIORATION_BROKEN_HIGH);
				else result += ReplaceText(GetMsgStr(TEXTMSG_GAME, STR_DETERIORATION_PROCENT), "VALUE", deterioration * 100 / MAX_DETERIORATION);

				// Service
				if(FLAG(brokenFlags,BI_SERVICE)) result += "\n" + GetMsgStr(TEXTMSG_GAME, STR_DETERIORATION_SERVICE);

				// Service ext
				if(FLAG(brokenFlags,BI_SERVICE_EXT)) result += "\n" + GetMsgStr(TEXTMSG_GAME, STR_DETERIORATION_SERVICE_EXT);

				// Broken count
				CritterCl@ chosen = GetChosen();
				if(valid(chosen) && chosen.Perk[PE_MR_FIXIT] != 0)
					result += "\n" + ReplaceText(GetMsgStr(TEXTMSG_GAME, STR_DETERIORATION_BROKEN_COUNT), "VALUE", brokenCount);
			}
			
			
			// Ammo extra info
			if(item.GetType() == ITEM_TYPE_AMMO)
			{
				result += "\n";
				string str;
				str += "AC : " += item.Proto.Ammo_ACMod + "\n";		//Armor class reduction
				str += "DR : " += item.Proto.Ammo_DRMod + "%\n";	//Damage resistance reduction
				str += "DM : " += item.Proto.Ammo_DmgMult + "/" + item.Proto.Ammo_DmgDiv;
				result += str;
			}

			// Ammo load
			if(item.GetType() == ITEM_TYPE_WEAPON && item.Proto.Weapon_MaxAmmoCount > 0)
			{
				result += "\n";
				string str = GetMsgStr(TEXTMSG_GAME, STR_INV_HAS_SHOTS);
				str = ReplaceText(str,"VALUE",     item.AmmoCount);
				str = ReplaceText(str,"MAX_VALUE", item.Proto.Weapon_MaxAmmoCount);
				str = ReplaceText(str,"AMMO",      GetMsgStr(TEXTMSG_GAME, STR_CALIBER(item.Proto.Weapon_Caliber)));
				result += str;
			}
			
			result += "\n";
			result += "---------------------";
			
			//add perks in description with color
			if(item.GetType() == ITEM_TYPE_WEAPON && item.Proto.Weapon_Perk1 >0 && item.Proto.Weapon_Perk2 >0 && item.Proto.Weapon_Perk3 >0 && item.Proto.Weapon_Perk4 >0 && item.Proto.Weapon_Perk5 >0 && item.Proto.Weapon_Perk6 >0)
			{
				result += "\n";
				string str;
				str = GetMsgStr(TEXTMSG_GAME, STR_WPN_PERK(item.Proto.Weapon_Perk1));
				result += str;
				result += "\n";
				result += "|" + colorYellow + " ";
				str = GetMsgStr(TEXTMSG_GAME, STR_WPN_PERK(item.Proto.Weapon_Perk2));
				result += str;
				result += "\n";
				result += "|" + colorPink + " ";
				str = GetMsgStr(TEXTMSG_GAME, STR_WPN_PERK(item.Proto.Weapon_Perk3));
				result += str;
				result += "\n";
				result += "|" + colorOrange + " ";
				str = GetMsgStr(TEXTMSG_GAME, STR_WPN_PERK(item.Proto.Weapon_Perk4));
				result += str;
				result += "\n";	
				result += "|" + colorRed + " ";				
				str = GetMsgStr(TEXTMSG_GAME, STR_WPN_PERK(item.Proto.Weapon_Perk5));
				result += str;
				result += "\n";	
				result += "|" + colorTurquoise + " ";
				str = GetMsgStr(TEXTMSG_GAME, STR_WPN_PERK(item.Proto.Weapon_Perk6));
				result += str;
				result += "|" + colorGreen + " ";
			}

			result += "\n";
			
			//add weapon exp in description;
			if(item.GetType() == ITEM_TYPE_WEAPON && item.Proto.Weapon_Perk1 >0 && item.Proto.Weapon_Perk2 >0 && item.Proto.Weapon_Perk3 >0 && item.Proto.Weapon_Perk4 >0 && item.Proto.Weapon_Perk5 >0 && item.Proto.Weapon_Perk6 >0) 
				{
				string str;
				uint exp = item.Val5;
				str += "Experience : " += exp + "/";
				if(exp <= 999) 
				{
					str += "|" + colorGreen + " ";
					str += "1000";
				}	
				if(exp <= 1999 && exp >= 1000) 
				{
					str += "|" + colorYellow + " ";
					str += "2000";
				}	
				if(exp <= 2999 && exp >= 2000) 
				{
					str += "|" + colorPink + " ";
					str += "3000";
				}
				if(exp <= 3999 && exp >= 3000) 
				{
					str += "|" + colorOrange + " ";
					str += "4000";
				}
				if(exp <= 4999 && exp >= 4000) 
				{
					str += "|" + colorRed + " ";
					str += "5000";
				}
				if(exp <= 5999 && exp >= 5000) 
				{
					str += "|" + colorTurquoise + " ";
					str += "6000";
				}
				if(exp >= 6000) 
				{
					str += "|" + colorTurquoise + " ";
					str += "lvlcap";
				}
				result += str;
				}
				result += "\n";
				result += "\n";

			// Key id
			if(item.GetType()==ITEM_TYPE_KEY)
				result += "\n"+ReplaceText(GetMsgStr(TEXTMSG_GAME, STR_INV_KEY_NUMBER), "KEY_ID", item.LockerId);
		}
	}

	// Format tags
	if(item.Lexems != "") return FormatTags(result, item.Lexems);
	return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
// Critter description. Look types look in _client_defines.fos, Critter look types.
string critter_description(CritterCl& cr, int lookType)
{
	string result;
	int gender = cr.Stat[ST_GENDER];
	if(GetChosen().ParamBase[PLAYER_ACCESS] == ACCESS_ADMIN) result = "ID:" + "(" + cr.Id + ") ";
	// Player
	if(cr.IsPlayer())
	{
		// Only name
		if(lookType == CRITTER_ONLY_NAME)
		{
			result = cr.Name; // No change
		}
		// Short info
		else if(lookType == CRITTER_LOOK_SHORT)
		{
			result += GetMsgStr(TEXTMSG_GAME, STR_CRIT_LOOK1(gender));
			result += cr.Name;
			result += ".";
		}
		// Full info
		else
		{
			result += GetMsgStr(TEXTMSG_GAME, STR_CRIT_LOOK1(gender));

			// Age
			uint ageStr = GetMsgStrNumUpper(TEXTMSG_GAME, STR_CRIT_LOOK_AGE(gender, cr.Stat[ST_AGE]));
			if(ageStr != 0)
				result += GetMsgStr(TEXTMSG_GAME, ageStr);
			else
				result += cr.Name;
			result += ".";
/*
			// Condition
			if(IsMsgStr(TEXTMSG_GAME, STR_CRIT_LOOK_COND(gender, cr.Cond, cr.CondExt)))
			{
				result += ", ";
				result += GetMsgStr(TEXTMSG_GAME, STR_CRIT_LOOK_COND(gender, cr.Cond, cr.CondExt));
			}

			// Special
			uint[] special;
			for(uint i = 0; i < 7 ; i++)
			{
				if(not IsMsgStr(TEXTMSG_GAME, STR_CRIT_LOOK_SPEC(gender, i, cr.Stat[ST_STRENGTH + i]))) continue;
				special.insertLast(i);
			}

			if(special.length()>0)
			{
				result += ". ";
				result += GetMsgStr(TEXTMSG_GAME, STR_CRIT_LOOK2(gender));

				for(uint i = 0, j = special.length(); i < j; i++)
				{
					uint sp = special[i];
					result += GetMsgStr(TEXTMSG_GAME, STR_CRIT_LOOK_SPEC(gender, sp, cr.Stat[ST_STRENGTH + sp]));

					if(i == j - 1) break;
					else if(i == j - 2) result += GetMsgStr(TEXTMSG_GAME, STR_AND);
					else result += ", ";
				}
			}

			// Damage
			uint[] damage;
			for(uint i = 0; i < 7; i++)
			{
				if(cr.GetPerk(PE_DAMAGE_POISONED + i) != 0 && IsMsgStr(TEXTMSG_GAME, STR_CRIT_LOOK_DMG(gender, i)))
					damage.insertLast(i);
			}

			if(damage.length() > 0)
			{
				result += ". ";
				result += GetMsgStr(TEXTMSG_GAME, STR_CRIT_LOOK3(gender));

				for(uint i = 0, j = damage.length(); i < j; i++)
				{
					uint dmg = damage[i];
					result += GetMsgStr(TEXTMSG_GAME, STR_CRIT_LOOK_DMG(gender, dmg));

					if(i == j - 1) break;
					else if(i == j - 2) result += GetMsgStr(TEXTMSG_GAME, STR_AND);
					else result += ", ";
				}
				result += ".";
			}

			// Perks
			for(uint i = 0; i <= PE_SEPARATED_KARMA; i++)
			{
				if(cr.GetPerk(i) != 0 && IsMsgStr(TEXTMSG_GAME, STR_CRIT_LOOK_PERK(gender, i)))
				{
					result += " ";
					result += GetMsgStr(TEXTMSG_GAME, STR_CRIT_LOOK_PERK(gender, i));
				}
			}
			if(result.length() > 0 && result[result.length() - 1] != ".") result += ".";*/
		}
	}
	// Npc
	else
	{
		uint dlgId = cr.Stat[ST_DIALOG_ID];
		uint16 npcPid = cr.Pid;
		bool defaultText = false;

		if(lookType == CRITTER_ONLY_NAME)
		{
			result = GetMsgStr(TEXTMSG_DLG, STR_NPC_NAME(dlgId, npcPid));
		}
		// Short info
		else if(lookType == CRITTER_LOOK_SHORT)
		{
			if(cr.IsLife() && IsMsgStr(TEXTMSG_DLG, STR_NPC_INFO_LIFE(dlgId, npcPid)))        result += GetMsgStr(TEXTMSG_DLG, STR_NPC_INFO_LIFE(dlgId, npcPid));
			else if(cr.IsKnockout() && IsMsgStr(TEXTMSG_DLG, STR_NPC_INFO_KO(dlgId, npcPid))) result += GetMsgStr(TEXTMSG_DLG, STR_NPC_INFO_KO(  dlgId, npcPid));
			else if(cr.IsDead() && IsMsgStr(TEXTMSG_DLG, STR_NPC_INFO_DEAD(dlgId, npcPid)))   result += GetMsgStr(TEXTMSG_DLG, STR_NPC_INFO_DEAD(dlgId, npcPid));
			else defaultText = true;
		}
		// Full info
		else
		{
			if(cr.IsLife() && IsMsgStr(TEXTMSG_DLG, STR_NPC_FULL_INFO_LIFE(dlgId, npcPid)))        result += GetMsgStr(TEXTMSG_DLG, STR_NPC_FULL_INFO_LIFE(dlgId, npcPid));
			else if(cr.IsKnockout() && IsMsgStr(TEXTMSG_DLG, STR_NPC_FULL_INFO_KO(dlgId, npcPid))) result += GetMsgStr(TEXTMSG_DLG, STR_NPC_FULL_INFO_KO(  dlgId, npcPid));
			else if(cr.IsDead() && IsMsgStr(TEXTMSG_DLG, STR_NPC_FULL_INFO_DEAD(dlgId, npcPid)))   result += GetMsgStr(TEXTMSG_DLG, STR_NPC_FULL_INFO_DEAD(dlgId, npcPid));
			else defaultText = true;
		}

		if(defaultText)
		{
			// Check standart text
			if(IsMsgStr(TEXTMSG_DLG, STR_NPC_NAME(dlgId, npcPid)))
			{
				if(cr.IsLife())          result += ReplaceText(GetMsgStr(TEXTMSG_GAME, STR_CRIT_LOOK_LIFE), "NAME", GetMsgStr(TEXTMSG_DLG, STR_NPC_NAME(dlgId, npcPid)));
				else if(cr.IsKnockout()) result += ReplaceText(GetMsgStr(TEXTMSG_GAME, STR_CRIT_LOOK_KO)  , "NAME", GetMsgStr(TEXTMSG_DLG, STR_NPC_NAME(dlgId, npcPid)));
				else if(cr.IsDead())     result += ReplaceText(GetMsgStr(TEXTMSG_GAME, STR_CRIT_LOOK_DEAD), "NAME", GetMsgStr(TEXTMSG_DLG, STR_NPC_NAME(dlgId, npcPid)));
			}
			// Set default text
			else
			{
				result += GetMsgStr(TEXTMSG_GAME, STR_CRIT_LOOK_NOTHING);
			}
		}
	}

	// Additional description
	if(lookType == CRITTER_LOOK_FULL)
	{
		if(result.length() > 0 && result[result.length() - 1] != ".") result += ".";
		result += " ";

		CritterCl@ chosen = GetChosen();
		if(valid(chosen) && chosen.Perk[PE_AWARENESS] != 0) // Awareness
		{
			result += GetMsgStr(TEXTMSG_GAME, STR_CRIT_LOOK_HP(gender));
			result = ReplaceText(result, "CUR", cr.Stat[ST_CURRENT_HP]);
			result = ReplaceText(result, "MAX", cr.Stat[ST_MAX_LIFE]);

			ItemCl@ item = cr.GetItem(0, SLOT_HAND1);
			if(_CritIsInjured(cr))
			{
				if(valid(item))
					result += ", ";
				else
					result += GetMsgStr(TEXTMSG_GAME, STR_AND);

				result += GetMsgStr(TEXTMSG_GAME, STR_CRIT_LOOK_LIMBS(gender, false));
			}

			if(valid(item))
			{
				if(item.GetType() == ITEM_TYPE_WEAPON)
				{
					if(item.Proto.Weapon_MaxAmmoCount == 0)
					{
						result += GetMsgStr(TEXTMSG_GAME, STR_CRIT_LOOK_WEAP);
						result = ReplaceText(result, "WEAPON", GetMsgStr(TEXTMSG_ITEM, STR_ITEM_INFO(item)));
					}
					else
					{
						result += GetMsgStr(TEXTMSG_GAME, STR_CRIT_LOOK_WEAP_AMMO);
						result = ReplaceText(result, "WEAPON", GetMsgStr(TEXTMSG_ITEM, STR_ITEM_INFO(item)));
						result = ReplaceText(result, "CUR"   , item.AmmoCount);
						result = ReplaceText(result, "MAX"   , item.Proto.Weapon_MaxAmmoCount);
						result = ReplaceText(result, "AMMO"  , GetMsgStr(TEXTMSG_GAME, STR_CALIBER(item.Proto.Weapon_Caliber)));
					}
				}
				else
				{
					result += GetMsgStr(TEXTMSG_GAME, STR_CRIT_LOOK_MISC);
					result = ReplaceText(result, "MISC", GetMsgStr(TEXTMSG_ITEM, STR_ITEM_INFO(item)));
				}
			}
		}
		else // Simple
		{
			if(GetChosen().ParamBase[PLAYER_ACCESS] == ACCESS_ADMIN) Message("Id:" + cr.Id);
			result += GetMsgStr(TEXTMSG_GAME, STR_CRIT_LOOK_WHO(gender));

			int hp_proc = cr.Stat[ST_CURRENT_HP] * 100 / cr.Stat[ST_MAX_LIFE];
			if(cr.IsDead())        result += GetMsgStr(TEXTMSG_GAME, STR_CRIT_LOOK_STATE(0));
			else if(hp_proc < 34)  result += GetMsgStr(TEXTMSG_GAME, STR_CRIT_LOOK_STATE(1));
			else if(hp_proc < 67)  result += GetMsgStr(TEXTMSG_GAME, STR_CRIT_LOOK_STATE(2));
			else if(hp_proc < 100) result += GetMsgStr(TEXTMSG_GAME, STR_CRIT_LOOK_STATE(3));
			else                   result += GetMsgStr(TEXTMSG_GAME, STR_CRIT_LOOK_STATE(4));

			if(_CritIsInjured(cr))
			{
				if(hp_proc < 90) result += GetMsgStr(TEXTMSG_GAME, STR_AND);
				result += GetMsgStr(TEXTMSG_GAME, STR_CRIT_LOOK_LIMBS(gender, hp_proc >= 90));
			}
		}
		result += ".";
	}

	// Format tags
	if(cr.Lexems != "") return FormatTags(result, cr.Lexems);
	return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
// Elevator generation.
// Data specification:
// 1
// 1 start level
// 1 levels count
// 1 main pic
// 2 main pic width, height
// 1 additional pic offset
// 2 additional pic point
// 1 indicator animation offset in INTRFACE.LST
// 2 indicator animation point
// 1 button down pic offset in INTRFACE.LST
// 1 buttons count
// 4 rect for every button
bool get_elevator(uint type, uint[]& data)
{
	const string iface = "art\\intrface\\";
	const uint[][] elevators={
	//	 Level current, start, count               Main picture size                          Additional picture size                            Indicator animation size                  Buttons count
	//	         Main picture                               Additional picture                       Indicator animation                                  Button down picture                 Button coordinates
		// 0) BOS 1234
		{0,1,4,  GetStrHash(iface+"EL_BOS.FRM"),   230,284, 0,                                0, 0,  GetStrHash(iface+"elevator_indicator.frm"), 121,41,  GetStrHash(iface+"EBUT_IN.FRM"), 4, 11,42,58,91, 11,102,58,151, 11,162,58,211, 11,222,58,271},
		// 1) BOS G1
		{0,0,2,  GetStrHash(iface+"EL_BOS.FRM"),   230,284, GetStrHash(iface+"EL_BOS2.FRM"),  0,37,  GetStrHash(iface+"elevator_indicator.frm"), 121,41,  GetStrHash(iface+"EBUT_IN.FRM"), 2, 11,42,58,91, 11,102,58,151},
		// 2) Master 123
		{0,1,3,  GetStrHash(iface+"EL_MAST1.FRM"), 230,284, 0,                                0, 0,  GetStrHash(iface+"elevator_indicator.frm"), 121,41,  GetStrHash(iface+"EBUT_IN.FRM"), 3, 11,42,58,91, 11,102,58,151, 11,162,58,211},
		// 3) Master 34
		{0,3,2,  GetStrHash(iface+"EL_MAST1.FRM"), 230,284, GetStrHash(iface+"EL_MAST2.FRM"), 0,37,  GetStrHash(iface+"elevator_indicator.frm"), 121,41,  GetStrHash(iface+"EBUT_IN.FRM"), 2, 11,42,58,91, 11,102,58,151},
		// 4) Military 123
		{0,1,3,  GetStrHash(iface+"EL_MIL1.FRM"),  231,285, 0,                                0, 0,  GetStrHash(iface+"elevator_indicator.frm"), 121,41,  GetStrHash(iface+"EBUT_IN.FRM"), 3, 11,42,58,91, 11,102,58,151, 11,162,58,211},
		// 5) Military 34
		{0,3,4,  GetStrHash(iface+"EL_MIL1.FRM"),  231,285, GetStrHash(iface+"EL_MIL2.FRM"),  0,37,  GetStrHash(iface+"elevator_indicator.frm"), 121,41,  GetStrHash(iface+"EBUT_IN.FRM"), 2, 11,42,58,91, 11,102,58,151},
		// 6) Military 346
		{0,3,3,  GetStrHash(iface+"EL_MIL1.FRM"),  231,285, GetStrHash(iface+"EL_MIL3.FRM"),  0,37,  GetStrHash(iface+"elevator_indicator.frm"), 121,41,  GetStrHash(iface+"EBUT_IN.FRM"), 3, 11,42,58,91, 11,102,58,151, 11,162,58,211},
		// 7) Military 456
		{0,4,3,  GetStrHash(iface+"EL_MIL1.FRM"),  231,285, GetStrHash(iface+"EL_MIL4.FRM"),  0,37,  GetStrHash(iface+"elevator_indicator.frm"), 121,41,  GetStrHash(iface+"EBUT_IN.FRM"), 3, 11,42,58,91, 11,102,58,151, 11,162,58,211},
		// 8) Vault 123
		{0,1,3,  GetStrHash(iface+"EL_VAULT.FRM"), 230,284, 0,                                0, 0,  GetStrHash(iface+"elevator_indicator.frm"), 121,41,  GetStrHash(iface+"EBUT_IN.FRM"), 3, 11,42,58,91, 11,102,58,151, 11,162,58,211},
	};

	uint index        = (type & 0xFFFF);
	uint currentLevel = (type >> 16);

	if(index > 8) return false;
	data.resize(elevators[index].length());
	for(uint i = 0; i < data.length(); i++) data[i] = elevators[index][i];
	data[0] = currentLevel;
	return true;
}


////////////////////////////////////////////////////////////////////////////////////////////////////
// Music/Video, see media.fos
void _PlayMusic(int pos, int repeat, int, string@ musicName, int[]@)
{
	PlayMusic(musicName, uint(pos), uint(repeat));
}

void _PlaySound(int pos, int repeat, int, string@ musicName, int[]@)
{
	PlayMusic(musicName, uint(pos), uint(repeat));
}

void _PlayVideo(int canStop, int, int, string@ videoName, int[]@)
{
	PlayVideo(videoName, canStop != 0);
}

////////////////////////////////////////////////////////////////////////////////////////////////////
// Effects, see effects.fos
void _FlushScreen(int fromColor, int toColor, int timeMs, string@, int[]@)
{
	FlushScreen(fromColor, toColor, timeMs);
}

void _QuakeScreen(int noise, int timeMs, int, string@, int[]@)
{
	QuakeScreen(noise, timeMs);
}

////////////////////////////////////////////////////////////////////////////////////////////////////
// Call to determine cost of single item.
// To allow function set __CustomItemCost to true.
// Don't forgot specify this function in client script.
uint item_cost(ItemCl& item, CritterCl& chosen, CritterCl& npc, bool sell)
{
	return sell ? 1 : 2;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
// Call to determine perk aviability.
bool check_perk(CritterCl& cr, uint perk)
{
	return PerkCheck(cr, perk);
}

////////////////////////////////////////////////////////////////////////////////////////////////////
// Call to calculate registration data.
// Input: 7 special, 3 tag skills, 2 traits, age, gender
void player_data_generate(int[]& data)
{
	CritterGenerate(data);

#ifdef PLAYERS_3D
	Set3DRegistrationGender(data[ST_GENDER]);
#endif
}

bool player_data_check(string& name, int[]& data)
{
	#ifdef PLAYERS_3D
		Fill3DRegistrationParameters(data);
	#endif
	// Check name
    uint nameError = CheckPlayerName( name );
    if( nameError != 0 )
    {
        Message( GetMsgStr( TEXTMSG_GAME, nameError ) );
        return false;
    }


	return CritterGenerateCheck(data);
}

////////////////////////////////////////////////////////////////////////////////////////////////////
// Call on some critter action.
void critter_action(bool localCall, CritterCl& cr, int action, int actionExt, ItemCl@ item)
{
	// Not process locally called actions
	if(cr.IsChosen() && not localCall)
	{
		switch(action)
		{
		case ACTION_MOVE_ITEM:
		case ACTION_MOVE_ITEM_SWAP:
		case ACTION_USE_ITEM:
		case ACTION_DROP_ITEM:
		case ACTION_USE_WEAPON:
		case ACTION_RELOAD_WEAPON:
		case ACTION_USE_SKILL:
		case ACTION_PICK_ITEM:
		case ACTION_PICK_CRITTER:
		case ACTION_OPERATE_CONTAINER:
			return; // Skip processing
		default:
			break;  // Processing
		}
	}

	uint8 mode = 0;
	const ProtoItem@ proto = (valid(item) ? item.Proto : cr.GetSlotProto(SLOT_HAND1, mode));

	if((action >= ACTION_MOVE_ITEM && action <= ACTION_OPERATE_CONTAINER) || action == ACTION_STANDUP) cr.Wait(__Breaktime);

	switch(action)
	{
	case ACTION_MOVE:
		// Not implemented
		//cr.Wait(move time);
		break;
	case ACTION_RUN:
		// Not implemented
		// cr.Wait(run time);
		break;
	case ACTION_MOVE_ITEM:
		if(cr.IsLife())
		{
			uint8 fromSlot = actionExt;
			uint8 toSlot = item.CritSlot;

			cr.ClearAnim();

			if(toSlot == SLOT_HAND1)
				cr.Animate(0, ANIM2_SHOW_WEAPON, item);
			else if(fromSlot == SLOT_HAND1)
				cr.Animate(0, ANIM2_HIDE_WEAPON, item);
			else
				cr.Animate(0, ANIM2_SWITCH_ITEMS);
		}
		break;
	case ACTION_MOVE_ITEM_SWAP:
		break;		
	case ACTION_USE_ITEM:
		if(cr.IsLife() && valid(proto))
		{
			cr.ClearAnim();

			if(proto.Type == ITEM_TYPE_WEAPON && FLAG(proto.Flags, ITEM_CAN_USE_ON_SMTH) && cr.IsAnimAviable(proto.Weapon_Anim1, proto.Weapon_Anim2_0))
				cr.Animate(proto.Weapon_Anim1, proto.Weapon_Anim2_0, item);
			else
				cr.Animate(0, ANIM2_USE, item);
		}
		break;
	case ACTION_DROP_ITEM:
		if(cr.IsLife())
		{
			cr.ClearAnim();
			cr.Animate(0, ANIM2_PICKUP);
		}
		break;
	case ACTION_USE_WEAPON:
		if(cr.IsLife() && valid(proto))
		{
			int use   = (actionExt & 0xF);
			int aim   = ((actionExt >> 4) & 0xF);
			bool fail = (((actionExt >> 8) & 1) != 0);

			cr.ClearAnim();

			cr.Animate(0, ANIM2_PREPARE_WEAPON);

			PlaySound('W', SOUND_WEAPON_USE, _WeaponSoundId(proto, use), use != 1 ? '1' : '2');
			cr.Animate(0, _WeaponAnim2(proto, use), item);

			if(fail)
				cr.Animate(0, ANIM2_DAMAGE_FRONT, item);
			else
				cr.Animate(0, ANIM2_TURNOFF_WEAPON);
		}
		break;
	case ACTION_RELOAD_WEAPON:
		if(cr.IsLife() && valid(proto))
		{
			cr.ClearAnim();
			PlaySound('W', SOUND_WEAPON_RELOAD, proto.Weapon_SoundId_0, '1');
			cr.Animate(item.Proto.Weapon_Anim1, ANIM2_RELOAD, item);
		}
		break;
	case ACTION_USE_SKILL:
		if(cr.IsLife() && actionExt != SK_SNEAK && actionExt != SK_STEAL)
		{
			cr.ClearAnim();
			cr.Animate(0, ANIM2_USE);
		}
		break;
	case ACTION_PICK_ITEM:
		if(cr.IsLife() && valid(proto))
		{
			cr.ClearAnim();
			cr.Animate(0, proto.GroundLevel ? ANIM2_PICKUP : ANIM2_USE);
		}
		break;
	case ACTION_PICK_CRITTER:
		if(cr.IsLife())
		{
			cr.ClearAnim();

			switch(actionExt) // 0 - loot, 1 - steal, 2 - push
			{
			case 0: cr.Animate(0, ANIM2_LOOT);  break;
			case 1: cr.Animate(0, ANIM2_STEAL); break;
			case 2: cr.Animate(0, ANIM2_PUSH);  break;
			default: break;
			}
		}
		break;
	case ACTION_OPERATE_CONTAINER:
		if(cr.IsLife())
		{
			cr.ClearAnim();
			int transferType  = actionExt/10;
			int directionType = actionExt%10;

			if(transferType == TRANSFER_HEX_CONT_DOWN || transferType == TRANSFER_CRIT_LOOT)
				cr.Animate(0, ANIM2_PICKUP);
			//animacja prezkС–adania przedmiotu warunek dla kradzieС—y
			else
				if(transferType == TRANSFER_CRIT_STEAL)
				{}
				else
				cr.Animate(0, ANIM2_USE);
		}
		break;
	case ACTION_DODGE:
		if(not cr.IsAnimPlaying() && cr.IsLife())
		{
			cr.Animate(0, actionExt == 0 ? ANIM2_DODGE_FRONT : ANIM2_DODGE_BACK);
		}
		break;
	case ACTION_DAMAGE:
		if(cr.IsChosen()) FlushScreen(0x30DD1111,0,500);
		if(not cr.IsAnimPlaying())
		{
			if(cr.IsLife())
				cr.Animate(0, actionExt == 0 ? ANIM2_DAMAGE_FRONT : ANIM2_DAMAGE_BACK);
			else if(cr.IsKnockout())
				cr.Animate(0, actionExt == 0 ? ANIM2_DAMAGE_PRONE_FRONT : ANIM2_DAMAGE_PRONE_BACK);
		}
		else
		{
			// Todo:
			// ANIM2_WALK_DAMAGE_FRONT
			// ANIM2_WALK_DAMAGE_BACK
			// ANIM2_LIMP_DAMAGE_FRONT
			// ANIM2_LIMP_DAMAGE_BACK
			// ANIM2_RUN_DAMAGE_FRONT
			// ANIM2_RUN_DAMAGE_BACK
		}
		break;
	case ACTION_DAMAGE_FORCE:
		if(cr.IsChosen()) FlushScreen(0x30DD1111,0,500);
		if(cr.IsLife())
		{
			cr.ClearAnim();
			cr.Animate(0, actionExt == 0 ? ANIM2_DAMAGE_FRONT : ANIM2_DAMAGE_BACK);
		}
		else if(cr.IsKnockout())
		{
			cr.ClearAnim();
			cr.Animate(0, actionExt == 0 ? ANIM2_DAMAGE_PRONE_FRONT : ANIM2_DAMAGE_PRONE_BACK);
		}
		break;
	case ACTION_KNOCKOUT:
		if(cr.IsChosen()) FlushScreen(0x30DD1111,0,500);
		if(not cr.IsKnockout())
		{
			cr.ClearAnim();
			cr.Animate(0, actionExt);
		}
		break;
	case ACTION_STANDUP:
		if(cr.IsKnockout())
		{
			cr.ClearAnim();
			cr.Animate(0, actionExt);
		}
		break;
	case ACTION_FIDGET:
		if(cr.IsLife() && not cr.IsAnimPlaying())
		{
			cr.Animate(0, ANIM2_FIDGET);
		}
		break;
	case ACTION_DEAD:
		if(cr.IsChosen()) FlushScreen(0x30DD1111,0,500);
		if(not cr.IsDead())
		{
			cr.ClearAnim();
			cr.Animate(0, actionExt);
		}
		break;
	case ACTION_CONNECT:
		break;
	case ACTION_DISCONNECT:
		break;
	case ACTION_RESPAWN:
		break;
	case ACTION_REFRESH:
		break;
	default:
		break;
	}
}

////////////////////////////////////////////////////////////////////////////////////////////////////
// Call before 2d animation playing.
void animation2d_process(bool animateStay, CritterCl& cr, uint anim1, uint anim2, ItemCl@ item)
{
	if(!animateStay) PlayAnimSound(cr.CrType, cr.Stat[ST_GENDER], anim1, anim2);
}

////////////////////////////////////////////////////////////////////////////////////////////////////
// Call before 3d animation playing.
void animation3d_process(bool animateStay, CritterCl& cr, uint anim1, uint anim2, ItemCl@ item)
{
	if(!animateStay) PlayAnimSound(cr.CrType, cr.Stat[ST_GENDER], anim1, anim2);

#ifdef PLAYERS_3D
	// You must implement this pids
#define PID_STRAWHAT                     	uint(-1) // Head slot
#define PID_ARMIN_CAP	                    uint(-2) // Head slot
#define PID_POWER_HELMET                    uint(-3) // Head slot
#define PID_MOTORCYCLE_HELMET               uint(-4) // Head slot
#define PID_TIBBETS_PRISON             		uint(-5) // Armor slot
#define PID_VAULT_SUIT             			uint(-6) // Armor slot

	// Change values
	uint8 mode = 0;
	uint16 armorPid   = (valid(cr.GetSlotProto(SLOT_ARMOR, mode)) ? cr.GetSlotProto(SLOT_ARMOR, mode).ProtoId : 0);
	uint16 weapPid    = (valid(item) ? item.GetProtoId() : cr.GetSlotProto(SLOT_HAND1, mode).ProtoId);
	uint16 weapExPid  = (valid(cr.GetSlotProto(SLOT_HAND2, mode)) ? cr.GetSlotProto(SLOT_HAND2, mode).ProtoId : 0);
	ItemCl@ armorItem = cr.GetItem(0, SLOT_ARMOR);
	ItemCl@ headItem  = null;

#ifndef PLAYERS_3D_NO_HEAD
	uint16 headPid    = (valid(cr.GetSlotProto(SLOT_HEAD,  mode)) ? cr.GetSlotProto(SLOT_HEAD,  mode).ProtoId : 0);
	ItemCl@ headItem  = cr.GetItem(0, SLOT_HEAD);
#endif
#ifdef PLAYERS_3D_NO_HEAD
	uint16 headPid    = 0;
#endif

	bool weapBigGun = false;
	if(valid(item))
	{
		if(FLAG(item.Flags, ITEM_BIG_GUN)) weapBigGun = true;
	}
	else
	{
		ItemCl@ weap = cr.GetItem(0, SLOT_HAND1);
		if(valid(weap) && FLAG(weap.Flags, ITEM_BIG_GUN)) weapBigGun = true;
	}

	int rhandleAtr  = 0;
	int lhandleAtr  = 0;
	int handsAtr    = 0;
	int bodyAtr     = 0;
	int feetAtr     = 0;
	int headAtr     = 0;
	int eyeAtr      = 0;
	int shoulderAtr = 0;
	int backAtr     = 0;
	int backpackAtr = 0;

	/*switch(armorPid)
	{
	case PID_LEATHER_JACKET_DE:
		bodyAtr     = ATTRIBUTE_Body_LeatherOutfit;
		handsAtr    = ATTRIBUTE_Hands_LeatherOutfit; // ATTRIBUTE_Hands_LeatherOutfitGauntlet
		feetAtr     = ATTRIBUTE_Feet_LeatherOutfit;
		shoulderAtr = ATTRIBUTE_Shoulderpieces_LeatherOutfit;
		break;
	case PID_POWERED_ARMOR:
	case PID_HARDENED_POWER_ARMOR:
		bodyAtr     = ATTRIBUTE_Body_PowerArmor;
		handsAtr    = ATTRIBUTE_Hands_PowerArmor;
		feetAtr     = ATTRIBUTE_Feet_PowerArmor;
		shoulderAtr = ATTRIBUTE_Shoulderpieces_PowerArmor;
		headAtr     = ATTRIBUTE_Head_ArmingCap;
#ifdef PLAYERS_3D_NO_HEAD
		headAtr     = ATTRIBUTE_Head_PowerArmor;
#endif
		break;
	case PID_TIBBETS_PRISON:
		bodyAtr     = ATTRIBUTE_Body_PrisonSuit;
		feetAtr     = ATTRIBUTE_Feet_PrisonSuit;
		backAtr     = armorItem.Val5;
		break;
	case PID_VAULT_SUIT:
		bodyAtr     = ATTRIBUTE_Body_VaultSuit;
		feetAtr     = ATTRIBUTE_Feet_VaultSuit;
		backAtr     = armorItem.Val5;
		break;
		// Missed models, set some default clothes
	case PID_LEATHER_ARMOR_DE:
	case PID_LEATHER_ARMOR_MK_II_DE:
	case PID_CURED_LEATHER_ARMOR_DE:
	case PID_METAL_ARMOR_DE:
	case PID_METAL_ARMOR_MK_II_DE:
	case PID_TESLA_ARMOR_DE:
	case PID_COMBAT_ARMOR_DE:
	case PID_COMBAT_ARMOR_MK_II_DE:
	case PID_CA_1:
	case PID_ADVANCED_POWER_ARMOR:
	case PID_ADVANCED_POWER_ARMOR_MK2:
	case PID_PURPLE_ROBE:
	case PID_KEEPBRIGE_ROBE:
		bodyAtr     = ATTRIBUTE_Body_PrisonSuit;
		feetAtr     = ATTRIBUTE_Feet_PrisonSuit;
		break;
	default:
		break;
	}*/

	// Temporary sets, mostly intended for work with PLAYERS_3D_NO_HEAD
	// Will be corrected as the development of the missing content
	switch(armorPid)
	{
	case PID_LEATHER_JACKET_DE:
		bodyAtr     = ATTRIBUTE_Body_LeatherOutfit;
		handsAtr    = ATTRIBUTE_Hands_LeatherOutfit;
		feetAtr     = ATTRIBUTE_Feet_LeatherOutfit;
		break;

	case PID_POWERED_ARMOR:
	case PID_HARDENED_POWER_ARMOR:
		bodyAtr     = ATTRIBUTE_Body_PowerArmor;
		handsAtr    = ATTRIBUTE_Hands_PowerArmor;
		feetAtr     = ATTRIBUTE_Feet_PowerArmor;
		headAtr     = ATTRIBUTE_Head_ArmingCap;
		break;

	case PID_TIBBETS_PRISON:
		bodyAtr     = ATTRIBUTE_Body_PrisonSuit;
		feetAtr     = ATTRIBUTE_Feet_PrisonSuit;
		backAtr     = armorItem.Val5;
		break;

	case PID_JUMPSUIT:
	case PID_FAKE_JUMPSUIT:
	case PID_VAULT_SUIT:
		bodyAtr     = ATTRIBUTE_Body_VaultSuit;
		feetAtr     = ATTRIBUTE_Feet_VaultSuit;
		backAtr     = armorItem.Val5;
		break;

	case PID_LEATHER_ARMOR_DE:
	case PID_LEATHER_ARMOR_MK_II_DE:
	case PID_CURED_LEATHER_ARMOR_DE:
		bodyAtr     = ATTRIBUTE_Body_LeatherOutfit;
		handsAtr    = ATTRIBUTE_Hands_LeatherOutfitGauntlet;
		feetAtr     = ATTRIBUTE_Feet_LeatherOutfit;
		shoulderAtr = ATTRIBUTE_Shoulderpieces_LeatherOutfit;
		break;

	case PID_METAL_ARMOR_DE:
	case PID_METAL_ARMOR_MK_II_DE:
	case PID_TESLA_ARMOR_DE:
		bodyAtr     = ATTRIBUTE_Body_PowerArmor;
		feetAtr     = ATTRIBUTE_Feet_PowerArmor;
		break;

	case PID_COMBAT_ARMOR_DE:
	case PID_COMBAT_ARMOR_MK_II_DE:
	case PID_CA_1:
	case PID_CHITIN_ARMOR_MK_II:
	case PID_CHITIN_ARMOR:
	case PID_BLACK_COMBAT_ARMOR:
		bodyAtr     = ATTRIBUTE_Body_CombatArmor;
		handsAtr    = ATTRIBUTE_Hands_CombatArmor;
		feetAtr     = ATTRIBUTE_Feet_CombatArmor;
		shoulderAtr = ATTRIBUTE_Shoulderpieces_CombatArmor;
#ifdef PLAYERS_3D_NO_HEAD
		headAtr     = ATTRIBUTE_Head_CombatArmor;
#endif
		break;

	case PID_ADVANCED_POWER_ARMOR:
	case PID_ADVANCED_POWER_ARMOR_MK2:
		bodyAtr     = ATTRIBUTE_Body_PowerArmor;
		handsAtr    = ATTRIBUTE_Hands_PowerArmor;
		feetAtr     = ATTRIBUTE_Feet_PowerArmor;
		shoulderAtr = ATTRIBUTE_Shoulderpieces_PowerArmor;
		headAtr     = ATTRIBUTE_Head_PowerArmor;
		break;

	case PID_PURPLE_ROBE:
		bodyAtr     = ATTRIBUTE_Body_PrisonSuit;
		feetAtr     = ATTRIBUTE_Feet_PrisonSuit;
		break;
	case PID_KEEPBRIGE_ROBE:
		bodyAtr     = ATTRIBUTE_Body_PrisonSuit;
		feetAtr     = ATTRIBUTE_Feet_PrisonSuit;
		headAtr     = ATTRIBUTE_Head_StrawHat;
		break;
	case PID_BLACK_ROBE:
		bodyAtr     = ATTRIBUTE_Body_PrisonSuit;
		feetAtr     = ATTRIBUTE_Feet_PrisonSuit;
		headAtr     = ATTRIBUTE_Head_ArmingCap;
		break;

	default:
		break;
	}

	// Head
	switch(headPid)
	{
	case PID_STRAWHAT:
		headAtr     = ATTRIBUTE_Head_StrawHat;
		break;
	case PID_ARMIN_CAP:
		headAtr     = ATTRIBUTE_Head_ArmingCap;
		break;
	case PID_POWER_HELMET:
		headAtr     = ATTRIBUTE_Head_PowerArmor;
		break;
	case PID_MOTORCYCLE_HELMET:
		headAtr     = (headItem.Val5 != 0 ? headItem.Val5 : ATTRIBUTE_Head_Motorcycle_White);
		break;
	default:
		break;
	}

	// Backpack
	if(     weapPid   == PID_BAG || weapPid   == PID_BROWN_BAG) backpackAtr = ATTRIBUTE_Backpack_PaLg01;
	else if(weapPid   == PID_BACKPACK)                          backpackAtr = ATTRIBUTE_Backpack_PaSm01;
	else if(weapExPid == PID_BAG || weapExPid == PID_BROWN_BAG) backpackAtr = ATTRIBUTE_Backpack_PaLg01;
	else if(weapExPid == PID_BACKPACK)                          backpackAtr = ATTRIBUTE_Backpack_PaSm01;

	// Hands
	if(weapPid == PID_POWER_FIST_DE || weapPid == PID_MEGA_POWER_FIST_DE)
	{
		handsAtr = ATTRIBUTE_Hands_PowerFist;
	}
	else if(weapBigGun)
	{
		rhandleAtr = GetHandleValue(weapPid);
	}
	else
	{
		rhandleAtr = GetHandleValue(weapPid);
		lhandleAtr = GetHandleValue(weapExPid);
	}

#ifdef PLAYERS_3D_VAULT_SUITE
	bool isSkeleton = (cr.CrType == CRTYPE_3D_MALE_SKELETON || cr.CrType == CRTYPE_3D_FEMALE_SKELETON);
	if(bodyAtr == 0 && !isSkeleton) bodyAtr = ATTRIBUTE_Body_VaultSuit;
#endif

	cr.Anim3dLayer[ANIM3D_LAYER_RHANDLE ] = rhandleAtr;
	cr.Anim3dLayer[ANIM3D_LAYER_LHANDLE ] = lhandleAtr;
	cr.Anim3dLayer[ANIM3D_LAYER_BODY    ] = bodyAtr;
	cr.Anim3dLayer[ANIM3D_LAYER_FEET    ] = feetAtr;
	cr.Anim3dLayer[ANIM3D_LAYER_HANDS   ] = handsAtr;
	cr.Anim3dLayer[ANIM3D_LAYER_HEAD    ] = headAtr;
	cr.Anim3dLayer[ANIM3D_LAYER_SHOULDER] = shoulderAtr;
	cr.Anim3dLayer[ANIM3D_LAYER_EYE     ] = eyeAtr;
	cr.Anim3dLayer[ANIM3D_LAYER_BACK    ] = backAtr;
	cr.Anim3dLayer[ANIM3D_LAYER_BACKPACK] = backpackAtr;

	// Set custom values
	for(uint i = ANIM3D_LAYER_SKIN; i <= ANIM3D_LAYER_BACKPACK; i++)
		if(cr.Stat[ST_ANIM3D_LAYERS + i] != 0) cr.Anim3dLayer[i] = cr.Stat[ST_ANIM3D_LAYERS + i];
#endif
}

#ifdef PLAYERS_3D
int GetHandleValue(uint16 pid)
{
	if(pid == 0 || (pid >= 1000 && pid <=1100)) return 0;

	int handle = 0;
	switch(pid)
	{
	case PID_ZIP_GUN_DE:                        handle = ATTRIBUTE_Handle_Weapon_22Autoloader;               break;
	case PID_9MM_MAUSER_DE:                     handle = ATTRIBUTE_Handle_Weapon_9mmAutoloader;              break;
	case PID_9MM_MAUSER_DE:                    handle = ATTRIBUTE_Handle_Weapon_22Autoloader;               break;
	case PID_14MM_PISTOL_DE:                    handle = ATTRIBUTE_Handle_Weapon_22Autoloader;               break;
	case PID_DESERT_EAGLE_DE:                   handle = ATTRIBUTE_Handle_Weapon_45Autoloader;               break;
	case PID_DESERT_EAGLE_EXT_MAG_DE:           handle = ATTRIBUTE_Handle_Weapon_45Autoloader_GunExtClip;    break;
	case PID_223_PISTOL_DE:                     handle = ATTRIBUTE_Handle_Weapon_223Autoloader;              break;
	case PID_44_MAGNUM_REVOLVER_DE:             handle = ATTRIBUTE_Handle_Weapon_44Revolver;                 break;
	case PID_44_MAGNUM_SPEEDLOADER_DE:          handle = ATTRIBUTE_Handle_Weapon_44Revolver;                 break;
	case PID_NEEDLER_PISTOL_DE:                 handle = ATTRIBUTE_Handle_Weapon_22Autoloader;               break;
	case PID_PK12_GAUSS_PISTOL_DE:              handle = ATTRIBUTE_Handle_Weapon_2mmGaussPistol;             break;
	case PID_HUNTING_RIFLE_DE:                  handle = ATTRIBUTE_Handle_Weapon_SawedOffShotgun;            break;
	case PID_SCOPED_HUNTING_RIFLE_DE:           handle = ATTRIBUTE_Handle_Weapon_SawedOffShotgun;            break;
	case PID_SPRINGER_RIFLE_DE:                 handle = ATTRIBUTE_Handle_Weapon_SawedOffShotgun;            break;
	case PID_ASSAULT_RIFLE_DE:                  handle = ATTRIBUTE_Handle_Weapon_SawedOffShotgun;            break;
	case PID_ASSAULT_RIFLE_EXT_MAG_DE:          handle = ATTRIBUTE_Handle_Weapon_SawedOffShotgun;            break;
	case PID_SNIPER_RIFLE_DE:                   handle = ATTRIBUTE_Handle_Weapon_SawedOffShotgun;            break;
	case PID_FN_FAL_DE:                         handle = ATTRIBUTE_Handle_Weapon_SawedOffShotgun;            break;
	case PID_FN_FAL_NIGHT_SCOPE_DE:             handle = ATTRIBUTE_Handle_Weapon_SawedOffShotgun;            break;
	case PID_FN_FAL_HPFA_DE:                    handle = ATTRIBUTE_Handle_Weapon_SawedOffShotgun;            break;
	case PID_RED_RYDER_BB_GUN_DE:               handle = ATTRIBUTE_Handle_Weapon_SawedOffShotgun;            break;
	case PID_RED_RYDER_LE_BB_GUN_DE:            handle = ATTRIBUTE_Handle_Weapon_SawedOffShotgun;            break;
	case PID_JONNY_BB_GUN_DE:                   handle = ATTRIBUTE_Handle_Weapon_SawedOffShotgun;            break;
	case PID_INDEPENDENT_DE:                    handle = ATTRIBUTE_Handle_Weapon_SawedOffShotgun;            break;
	case PID_M72_GAUSS_RIFLE_DE:                handle = ATTRIBUTE_Handle_Weapon_SawedOffShotgun;            break;
	case PID_ELEPHANT_GUN_DE:                   handle = ATTRIBUTE_Handle_Weapon_SawedOffShotgun;            break;
	case PID_SHOTGUN_DE:                        handle = ATTRIBUTE_Handle_Weapon_SawedOffShotgun;            break;
	case PID_SAWED_OFF_SHOTGUN_DE:              handle = ATTRIBUTE_Handle_Weapon_SawedOffShotgun;            break;
	case PID_COMBAT_SHOTGUN_DE:                 handle = ATTRIBUTE_Handle_Weapon_SawedOffShotgun;            break;
	case PID_HK_CAWS_DE:                        handle = ATTRIBUTE_Handle_Weapon_SawedOffShotgun;            break;
	case PID_PANCOR_JACKHAMMER_DE:              handle = ATTRIBUTE_Handle_Weapon_SawedOffShotgun;            break;
	case PID_10MM_SMG_DE:                       handle = ATTRIBUTE_Handle_Weapon_9mmMachinePistol;           break;
	case PID_HK_P90C_DE:                        handle = ATTRIBUTE_Handle_Weapon_9mmMachinePistol;           break;
	case PID_TOMMY_GUN_DE:                      handle = ATTRIBUTE_Handle_Weapon_SawedOffShotgun;            break;
	case PID_HK_G11_DE:                         handle = ATTRIBUTE_Handle_Weapon_9mmMachinePistol;           break;
	case PID_HK_G11E_DE:                        handle = ATTRIBUTE_Handle_Weapon_9mmMachinePistol;           break;
	case PID_GREASE_GUN_DE:                     handle = ATTRIBUTE_Handle_Weapon_9mmMachinePistol;           break;
	case PID_FLAMER_DE:                         handle = ATTRIBUTE_Handle_Weapon_Flamethrower;               break;
	case PID_IMPROVED_FLAMETHROWER_DE:          handle = ATTRIBUTE_Handle_Weapon_Flamethrower_FlamerExtTank; break;
	case PID_ROCKET_LAUNCHER_DE:                handle = ATTRIBUTE_Handle_Weapon_15mmArtemisRailGun;         break;
	case PID_MINIGUN_DE:                        handle = ATTRIBUTE_Handle_Weapon_223Minigun;                 break;
	case PID_AVENGER_MINIGUN_DE:                handle = ATTRIBUTE_Handle_Weapon_223Minigun;                 break;
	case PID_VINDICATOR_MINIGUN_DE:             handle = ATTRIBUTE_Handle_Weapon_223Minigun;                 break;
	case PID_BOZAR_DE:                          handle = ATTRIBUTE_Handle_Weapon_LaserArraygun;              break;
	case PID_LIGHT_SUPPORT_WEAPON_DE:           handle = ATTRIBUTE_Handle_Weapon_LaserArraygun;              break;
	case PID_M60_DE:                            handle = ATTRIBUTE_Handle_Weapon_LaserArraygun;              break;
	case PID_LASER_PISTOL_DE:                   handle = ATTRIBUTE_Handle_Weapon_LaserPistol;                break;
	case PID_MAGNETO_LASER_PISTOL_DE:           handle = ATTRIBUTE_Handle_Weapon_LaserPistol;                break;
	case PID_SOLAR_SCORCHER_DE:                 handle = ATTRIBUTE_Handle_Weapon_APOLLOLaserPistol;          break;
	case PID_LASER_RIFLE_DE:                    handle = ATTRIBUTE_Handle_Weapon_LaserArraygun;              break;
	case PID_LASER_RIFLE_EXT_CAP_DE:            handle = ATTRIBUTE_Handle_Weapon_LaserArraygun;              break;
	case PID_GATLING_LASER_DE:                  handle = ATTRIBUTE_Handle_Weapon_223Minigun;                 break;
	case PID_ALIEN_LASER_PISTOL_DE:             handle = ATTRIBUTE_Handle_Weapon_APOLLOLaserPistol;          break;
	case PID_PLASMA_PISTOL_DE:                  handle = ATTRIBUTE_Handle_Weapon_LaserPistol;                break;
	case PID_PLASMA_PISTOL_EXT_CART_DE:         handle = ATTRIBUTE_Handle_Weapon_LaserPistol;                break;
	case PID_PLASMA_RIFLE_DE:                   handle = ATTRIBUTE_Handle_Weapon_LaserArraygun;              break;
	case PID_TURBO_PLASMA_RIFLE_DE:             handle = ATTRIBUTE_Handle_Weapon_LaserArraygun;              break;
	case PID_YK32_PULSE_PISTOL_DE:              handle = ATTRIBUTE_Handle_Weapon_2mmGaussPistol;             break;
	case PID_YK42B_PULSE_RIFLE_DE:              handle = ATTRIBUTE_Handle_Weapon_LaserArraygun;              break;
	case PID_MOLOTOV_COCKTAIL_DE:               handle = ATTRIBUTE_Handle_Weapon_GrenadeFrag;                break;
	case PID_FRAG_GRENADE_DE:                   handle = ATTRIBUTE_Handle_Weapon_GrenadeFrag;                break;
	case PID_PLASMA_GRENADE_DE:                 handle = ATTRIBUTE_Handle_Weapon_GrenadePlasma;              break;
	case PID_PULSE_GRENADE_DE:                  handle = ATTRIBUTE_Handle_Weapon_GrenadeEMP;                 break;
	case PID_FLARE_DE:                          handle = ATTRIBUTE_Handle_Weapon_Flare;                      break;
	case PID_ACTIVE_FLARE_DE:                   handle = ATTRIBUTE_Handle_Weapon_Flare;                      break;
	case PID_PLANT_SPIKE_DE:                    handle = ATTRIBUTE_Handle_Weapon_Rock;                       break;
	case PID_THROWING_KNIFE_DE:                 handle = ATTRIBUTE_Handle_Weapon_ThrowingKnife;              break;
	case PID_ROCK_DE:                           handle = ATTRIBUTE_Handle_Weapon_Rock;                       break;
	case PID_GOLD_NUGGET_DE:                    handle = ATTRIBUTE_Handle_Weapon_Rock;                       break;
	case PID_URANIUM_ORE_DE:                    handle = ATTRIBUTE_Handle_Weapon_Rock;                       break;
	case PID_REFINED_ORE_DE:                    handle = ATTRIBUTE_Handle_Weapon_Rock;                       break;
	case PID_KNIFE_DE:                          handle = ATTRIBUTE_Handle_Weapon_CombatKnife;                break;
	case PID_COMBAT_KNIFE_DE:                   handle = ATTRIBUTE_Handle_Weapon_CombatKnife;                break;
	case PID_LIL_JESUS_WEAPON_DE:               handle = ATTRIBUTE_Handle_Weapon_CombatKnife;                break;
	case PID_SHIV_DE:                           handle = ATTRIBUTE_Handle_Weapon_Shiv;                       break;
	case PID_SWITCHBLADE_DE:                    handle = ATTRIBUTE_Handle_Weapon_Switchblade;                break;
	case PID_WAKIZASHI_BLADE_DE:                handle = ATTRIBUTE_Handle_Weapon_Machete;                    break;
	case PID_SPEAR_DE:                          handle = ATTRIBUTE_Handle_Weapon_Spear;                      break;
	case PID_SHARP_SPEAR_DE:                    handle = ATTRIBUTE_Handle_Weapon_Spear;                      break;
	case PID_SHARPENED_POLE_DE:                 handle = ATTRIBUTE_Handle_Weapon_Spear;                      break;
	case PID_AXE:                            handle = ATTRIBUTE_Handle_Weapon_Hatchet;                    break;
	case PID_CLUB_DE:                           handle = ATTRIBUTE_Handle_Weapon_NightStick;                 break;
	case PID_CROWBAR_DE:                        handle = ATTRIBUTE_Handle_Weapon_Crowbar;                    break;
	case PID_WRENCH_DE:                         handle = ATTRIBUTE_Handle_Weapon_HeavyWrench;                break;
	case PID_SLEDGEHAMMER_DE:                   handle = ATTRIBUTE_Handle_Weapon_Sledgehammer;               break;
	case PID_LOUISVILLE_SLUGGER_DE:             handle = ATTRIBUTE_Handle_Weapon_Baseballbat;                break;
	case PID_SUPER_SLEDGE_DE:                   handle = ATTRIBUTE_Handle_Weapon_Sledgehammer;               break;
	case PID_CATTLE_PROD_DE:                    handle = ATTRIBUTE_Handle_Weapon_CattleProd;                 break;
	case PID_SUPER_CATTLE_PROD_DE:              handle = ATTRIBUTE_Handle_Weapon_CattleProd;                 break;
	case PID_RIPPER_DE:                         handle = ATTRIBUTE_Handle_Weapon_Machete;                    break;
	case PID_BOXING_GLOVES_DE:                  handle = ATTRIBUTE_Handle_Weapon_GrenadeBio;                 break;
	case PID_PLATED_BOXING_GLOVES_DE:           handle = ATTRIBUTE_Handle_Weapon_GrenadeBio;                 break;
	case PID_BRASS_KNUCKLES_DE:                 handle = ATTRIBUTE_Handle_Weapon_GrenadeBio;                 break;
	case PID_SPIKED_KNUCKLES_DE:                handle = ATTRIBUTE_Handle_Weapon_GrenadeBio;                 break;
	case PID_DYNAMITE:                       handle = ATTRIBUTE_Handle_Weapon_Dynamite;                   break;
	case PID_PLASTIC_EXPLOSIVES:             handle = ATTRIBUTE_Handle_Weapon_Dynamite;                   break;
	case PID_MINE:                           handle = ATTRIBUTE_Handle_Weapon_Dynamite;                   break;
	// Player will never have this weapons anyway
	case PID_ROBO_ROCKET_LAUNCHER_DE:           handle = ATTRIBUTE_Handle_Weapon_LaserArraygun;              break;
	case PID_PHAZER_DE:                         handle = ATTRIBUTE_Handle_Weapon_45Revolver;                 break;
	case PID_DEATHCLAW_CLAW_1_DE:               handle = ATTRIBUTE_Handle_Weapon_45Revolver;                 break;
	case PID_DEATHCLAW_CLAW_2_DE:               handle = ATTRIBUTE_Handle_Weapon_45Revolver;                 break;
	case PID_FIRE_GECKO_FLAME_WEAPON_DE:        handle = ATTRIBUTE_Handle_Weapon_Flamethrower;               break;
	case PID_SPECIAL_BOXER_WEAPON_DE:           handle = ATTRIBUTE_Handle_Weapon_45Revolver;                 break;
	case PID_GUN_TURRET_WEAPON_DE:              handle = ATTRIBUTE_Handle_Weapon_LaserArraygun;              break;
	case PID_EYEBALL_FIST_1_DE:                 handle = ATTRIBUTE_Handle_Weapon_45Revolver;                 break;
	case PID_EYEBALL_FIST_2_DE:                 handle = ATTRIBUTE_Handle_Weapon_45Revolver;                 break;
	case PID_DUAL_MINIGUN_DE:                   handle = ATTRIBUTE_Handle_Weapon_223Minigun;                 break;
	case PID_HEAVY_DUAL_MINIGUN_DE:             handle = ATTRIBUTE_Handle_Weapon_223Minigun;                 break;
	case PID_END_BOSS_KIFE_DE:                  handle = ATTRIBUTE_Handle_Weapon_Machete;                    break;
	case PID_END_BOSS_PLASMA_GUN_DE:            handle = ATTRIBUTE_Handle_Weapon_LaserArraygun;              break;
	case PID_HOLY_HAND_GRENADE_DE:              handle = ATTRIBUTE_Handle_Weapon_GrenadeFrag;                break;
	// Other items
	case PID_STIMPAK:
	case PID_RADAWAY:
	case PID_SUPER_STIMPAK:
	case PID_HYPO:
	case PID_PSYCHO:
	case PID_HYPO_POISON:                    handle = ATTRIBUTE_Handle_Item_FirstAidKit;                  break;
	case PID_LOCKPICKS:
	case PID_EXP_LOCKPICK_SET:
	case PID_ELECTRONIC_LOCKPICKS:
	case PID_ELEC_LOCKPICK_MKII:             handle = ATTRIBUTE_Handle_Item_SecurityKit;                  break;
	case PID_MULTI_TOOL:
	case PID_SUPER_TOOL_KIT:
	case PID_OIL_CAN:                        handle = ATTRIBUTE_Handle_Item_Toolkit;                      break;
	// No handle
	case PID_POWER_FIST_DE:
	case PID_MEGA_POWER_FIST_DE:
	case PID_BAG:
	case PID_BROWN_BAG:
	case PID_BACKPACK:                       handle = 0;                                                  break;
	// Generic item
	default:                                 handle = 0;                                                  break;
	}

	return handle;
}
#endif

////////////////////////////////////////////////////////////////////////////////////////////////////
// Called on some items collection generating.
// To force function call use RefreshItemsCollection(int collection)
// Collection constants see in Items collections _client_defines.fos
// If you want disable showing than just null pointer in collection
void items_collection(int collection, ItemCl@[]& items)
{
	// Example
	// Disable showing of all weapons in USE mode:
	/*if(collection == ITEMS_USE)
	{
		for(uint i = 0, j = items.length(); i < j; i++)
			if(items[i].GetType() == ITEM_TYPE_WEAPON)
				@items[i] = null;
	}*/

	if( collection == ITEMS_BARTER && __InventoryItemBarter != 0)
    {
        for( uint i = 0, j = items.length(); i < j; i++ )
        {
                if( valid(items[i]) && __InventoryItemBarter != items[i].GetType())@items[i] = null;
		}
	}
	if( collection ==  ITEMS_BARTER_OPPONENT && __InventoryItemBarterOpponent != 0)
    {
        for( uint i = 0, j = items.length(); i < j; i++ )
        {
                if( valid(items[i]) && __InventoryItemBarterOpponent != items[i].GetType())@items[i] = null;
		}
	}
}


////////////////////////////////////////////////////////////////////////////////////////////////////
// Called on log file saving.
void filename_logfile( string& filename )
{
	filename = "messagebox\\" + filename;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
// Called on screenshot saving.
void filename_screenshot( string& filename )
{
	filename = "screenshots\\" + filename;
}
