// Author: cvet, heX, Тринитротолуол, Tab10id
#include "_macros.fos"
#include "stdlib_h.fos"
#include "_defines.fos"

// Возвращает размер группы (живых ее участников)
// размер береться вне зависимости от того лидер это или просто партиец

#define FD_NO_MONEY_FOR_BASE		( 10 )
#define FD_MONEY_FOR_BASE			( 5 )

import void FlushScreen(Critter& cr, bool fadeOut, uint timeMs) from "effects";
import void ClearItems(Critter& cr) from "server_other_script";

int DFGroupCount(Critter& player, Critter@ npc)
{
	Critter @ leader;
	if (not valid(player.GetFollowLeader())) // если у игрока нет лидера
		@leader = player; // тогда считаем что он и есть лидер
		else
		@leader = player.GetFollowLeader(); // иначе берем лидера

	Critter@[] groups;
	groups.insertLast(@leader);
	leader.GetFollowGroup(FIND_LIFE,groups);
	return groups.length();
}

//!/ Размер группы больше >=VAL
bool d_GroupCountMore(Critter& player, Critter@ npc, int val)
{
	return DFGroupCount(player, npc)>=val;
}

bool d_GroupCountLess(Critter& player, Critter@ npc, int val)
{
	return DFGroupCount(player, npc)<val;
}

//!/ У всех уровень больше >=VAL
// Проверка что все игроки в группе больше или равны указанному уровню.
bool d_GroupLevelMore(Critter& player, Critter@ npc, int val)
{
	Critter@[] groups;
	groups.insertLast(@player);
	player.GetFollowGroup(FIND_LIFE,groups);
	for(uint i=0;i<groups.length();i++)
		if(groups[i].Stat[ST_LEVEL]<val) // если хотябы один из них меньше требуемого уровня
			return false;
	return true;
}

bool d_GroupLevelLess(Critter& player, Critter@ npc, int val)
{
	Critter@[] groups;
	groups.insertLast(@player);
	player.GetFollowGroup(FIND_LIFE,groups);
	for(uint i=0;i<groups.length();i++)
		if(groups[i].Stat[ST_LEVEL]>val) // если хотябы один из них меньше требуемого уровня
			return false;
	return true;
}

// Игрок нуждаеться в лечении?
bool d_IsToHeal(Critter& player, Critter@ npc)
{
	return player.Stat[ST_CURRENT_HP] < player.Stat[ST_MAX_LIFE];
}

// Игроку известна эта локация?
bool d_IsLocationVisible(Critter& player, Critter@ npc, int LocNum)
{
	return player.IsKnownLoc(false, uint16(LocNum));
}

// Игроку НЕ известна эта локация?
bool d_IsLocationNotVisible(Critter& player, Critter@ npc, int LocNum)
{
	return not player.IsKnownLoc( false, uint16(LocNum) );
}

// Есть зависимости от наркотиков?
bool d_IsAddict(Critter& player, Critter@ npc)
{
	for(uint i=ADDICTION_BEGIN;i<=ADDICTION_END;i++) if(player.Addiction[i]!=0) return true;
	return false;
}

// У игрока нет зависимостей от наркотиков?
bool d_IsNotAddict(Critter& player, Critter@ npc)
{
	return not d_IsAddict(player,npc);
}

// Игрок в группе? (лидер тоже считаеться)
bool d_GroupPresent(Critter& player, Critter@ npc)
{
	return DFGroupCount(player, npc)>1;
}

// Игрок НЕ в группе? (лидер тоже считаеться)
bool d_NotGroupPresent(Critter& player, Critter@ npc)
{
	return not d_GroupPresent(player, npc);
}

/** проверка на таймаут
 используйте функцию r_TimeoutSet для инициализации
 если таймаут кончился (или еще и не начинался)
 то функция вернет истинну (разрешит ответ)
 иначе вернет ложь (ответ будет скрыт)
*/
bool d_TimeoutCheck(Critter& player, Critter@ npc)
{
	GameVar @ t = GetLocalVar(LVAR_timeout, npc.Id);
	if(not valid(t)) return true; // таймаут еще и не начался
	if(__FullSecond >= uint(t.GetValue()))
		return true; // таймаут истек
		else
		return false; // таймаут еще жив
}

/**
	инверсия d_TimeoutCheck
*/
bool d_NotTimeoutCheck(Critter& player, Critter@ npc)
{
	return not d_TimeoutCheck(player, npc);
}


// Проверка уникальной переменной - таймаута игрок-нпц
// Время прошло, или таймаут не назначался
bool d_TimeoutOk(Critter & player, Critter @ npc)
{
	if(!valid(npc)) return false;
	GameVar @ to = GetUnicumVar(UVAR_uniq_timeout, player.Id, npc.Id);
	if(!valid(to)) return false;
	uint time = to.GetValue();
	if(time==0) return true;
	return (time<__FullSecond);
}

// Таймаут не закончился
bool d_NotTimeoutOk(Critter & player, Critter @ npc)
{
	return !d_TimeoutOk(player,npc);
}

bool d_CheckMonth(Critter & playe, Critter @npc, int monthFrom, int monthTo)
{
	return (__Month<=monthTo&&__Month>=monthFrom);
}

// НПЦ жив?
// в v0 указываем NpcRole НПЦ (на карте должен быть в 1 экземпляре)
// в v1 указываем PID карты (карта должна быть в игре в одном экземпляре)
bool d_IsLife(Critter& player, Critter@ npc, int v0, int v1)
{
	Map @ map = GetMapByPid(v1, 0);
	if(not valid(map)) { Log("error");return false;}
	Critter @ crit = map.GetNpc(v0, FIND_ALL|FIND_ONLY_NPC, 0);
	if(not valid(crit)) { Log("error");return false;}
	if(crit.IsLife())
		return true; else
		return false;
}

// НПЦ мертв?
bool d_IsDead(Critter& player, Critter@ npc, int v0, int v1)
{
	return not d_IsLife(player,npc,v0,v1);
}

// Шпионаж
void dlg_TrySpy( Critter& player, Critter@ banker, string@ playerName )
{
	if ( !valid(banker) ) return;
	if ( !IS_DIALOG_SAY_MODE(playerName) || IS_DIALOG_END(playerName) ) return;
	if ( playerName.length() <= 1 ) return;

	uint BankerDialog = banker.Stat[ST_DIALOG_ID];
	uint DlgStr = 100;
	string lexems = "$Victim " + playerName;

	Critter@ cr = GetPlayer(playerName);
	if ( !valid(cr) ) {
		player.SayMsg( SAY_DIALOG, TEXTMSG_DLG, DLGSTR( BankerDialog, DlgStr + 0 ), lexems );
		return;
	}

	if ( player.Id == cr.Id ){
		player.SayMsg( SAY_DIALOG, TEXTMSG_DLG, DLGSTR( BankerDialog, DlgStr + 9 ) );
		return;
	}

	// Пол.
	if ( cr.Stat[ST_GENDER] == GENDER_MALE) {
		lexems += "$Gender @msg dlg " + DLGSTR( BankerDialog, DlgStr + 10 ) + "@";
	} else if ( cr.Stat[ST_GENDER] == GENDER_FEMALE) {
		lexems += "$Gender @msg dlg " + DLGSTR( BankerDialog, DlgStr + 11 ) + "@";
	} else {
		lexems += "$Gender @msg dlg " + DLGSTR( BankerDialog, DlgStr + 12 ) + "@";
	}

	// Репликации.
	if ( cr.Stat[ST_REPLICATION_COUNT]/cr.Stat[ST_LEVEL] <= 2 ) {
		lexems += "$ReplCount @msg dlg " + DLGSTR( BankerDialog, DlgStr + 13 ) + "@";
	} else if ( cr.Stat[ST_REPLICATION_COUNT]/cr.Stat[ST_LEVEL] > 2 && cr.Stat[ST_REPLICATION_COUNT]/cr.Stat[ST_LEVEL] < 10 ) {
		lexems += "$ReplCount @msg dlg " + DLGSTR( BankerDialog, DlgStr + 14 ) + "@";
	} else {
		lexems += "$ReplCount @msg dlg " + DLGSTR( BankerDialog, DlgStr + 15 ) + "@";
	}

	// Год рождения.
	lexems += "$Born " + ( __Year - cr.Stat[ST_AGE] );

	if ( player.Skill[SK_SPEECH] >= 40 - ( player.Stat[ST_CHARISMA] + player.Stat[ST_LUCK] )/2 ) {
		player.SayMsg( SAY_DIALOG, TEXTMSG_DLG, DLGSTR( BankerDialog, DlgStr + 1 ), lexems );
	}

	// Уровень.
	if ( player.Skill[SK_SPEECH] >= 50 - ( player.Stat[ST_CHARISMA] + player.Stat[ST_LUCK] )/2 ) {
		lexems = "";
		lexems += "$Level " + cr.Stat[ST_LEVEL];
		player.SayMsg( SAY_APPEND, TEXTMSG_DLG, DLGSTR( BankerDialog, DlgStr + 2 ), lexems );
	}

	// Карма.
	if ( player.Skill[SK_SPEECH] >= 60 - ( player.Stat[ST_CHARISMA] + player.Stat[ST_LUCK] )/2 ) {
		int[] Values = { -2147483647, -1000, -750, -500, -250, 250,	500,	750,	1000 };
		int[] Descs =	{ 6125,				6122,	6119, 6116, 6113, 6110, 6107, 6104, 6101 };
		int CurKarma = 0;
		for ( uint i=0; i<Values.length(); i++ ){
			if ( int(cr.Stat[ST_KARMA]) >= Values[i] ) {
				CurKarma = Descs[i];
			} else {
				break;
			}
		}
		player.SayMsg( SAY_APPEND, TEXTMSG_GAME, CurKarma );
	}

	// Статы.
	if ( player.Skill[SK_SPEECH] >= 70 - ( player.Stat[ST_CHARISMA] + player.Stat[ST_LUCK] )/2 ) {
		lexems = "";
		// Сила.
		if ( cr.StatBase[ST_STRENGTH] < 4 ){
			lexems += "$Strength @msg dlg " + DLGSTR( BankerDialog, DlgStr + 16 ) + "@";
		} else if ( cr.StatBase[ST_STRENGTH] >= 4 && cr.StatBase[ST_STRENGTH] < 7 ){
			lexems += "$Strength" + "";
		} else if ( cr.StatBase[ST_STRENGTH] >= 7 && cr.StatBase[ST_STRENGTH] <= 8 ){
			lexems += "$Strength @msg dlg " + DLGSTR( BankerDialog, DlgStr + 17 ) + "@";
		} else {
			lexems += "$Strength @msg dlg " + DLGSTR( BankerDialog, DlgStr + 18 ) + "@";
		}
		// Восприятие.
		if ( cr.StatBase[ST_PERCEPTION] < 4 ){
			lexems += "$Perception @msg dlg " + DLGSTR( BankerDialog, DlgStr + 19 ) + "@";
		} else if ( cr.StatBase[ST_PERCEPTION] >= 4 && cr.StatBase[ST_PERCEPTION] < 7 ){
			lexems += "$Perception" + "";
		} else if ( cr.StatBase[ST_PERCEPTION] >= 7 && cr.StatBase[ST_PERCEPTION] <= 8 ){
			lexems += "$Perception @msg dlg " + DLGSTR( BankerDialog, DlgStr + 20 ) + "@";
		} else {
			lexems += "$Perception @msg dlg " + DLGSTR( BankerDialog, DlgStr + 21 ) + "@";
		}
		// Выносливость.
		if ( cr.StatBase[ST_ENDURANCE] < 4 ){
			lexems += "$Endurance @msg dlg " + DLGSTR( BankerDialog, DlgStr + 22 ) + "@";
		} else if ( cr.StatBase[ST_ENDURANCE] >= 4 && cr.StatBase[ST_ENDURANCE] < 7 ){
			lexems += "$Endurance" + "";
		} else if ( cr.StatBase[ST_ENDURANCE] >= 7 && cr.StatBase[ST_ENDURANCE] <= 8 ){
			lexems += "$Endurance @msg dlg " + DLGSTR( BankerDialog, DlgStr + 23 ) + "@";
		} else {
			lexems += "$Endurance @msg dlg " + DLGSTR( BankerDialog, DlgStr + 24 ) + "@";
		}
		// Обаяние.
		if ( cr.StatBase[ST_CHARISMA] < 4 ){
			lexems += "$Charisma @msg dlg " + DLGSTR( BankerDialog, DlgStr + 25 ) + "@";
		} else if ( cr.StatBase[ST_CHARISMA] >= 4 && cr.StatBase[ST_CHARISMA] < 7 ){
			lexems += "$Charisma" + "";
		} else if ( cr.StatBase[ST_CHARISMA] >= 7 && cr.StatBase[ST_CHARISMA] <= 8 ){
			lexems += "$Charisma @msg dlg " + DLGSTR( BankerDialog, DlgStr + 26 ) + "@";
		} else {
			lexems += "$Charisma @msg dlg " + DLGSTR( BankerDialog, DlgStr + 27 ) + "@";
		}
		// Интеллект.
		if ( cr.StatBase[ST_INTELLECT] < 4 ){
			lexems += "$Intellect @msg dlg " + DLGSTR( BankerDialog, DlgStr + 28 ) + "@";
		} else if ( cr.StatBase[ST_INTELLECT] >= 4 && cr.StatBase[ST_INTELLECT] < 7 ){
			lexems += "$Intellect" + "";
		} else if ( cr.StatBase[ST_INTELLECT] >= 7 && cr.StatBase[ST_INTELLECT] <= 8 ){
			lexems += "$Intellect @msg dlg " + DLGSTR( BankerDialog, DlgStr + 29 ) + "@";
		} else {
			lexems += "$Intellect @msg dlg " + DLGSTR( BankerDialog, DlgStr + 30 ) + "@";
		}
		// Ловкость.
		if ( cr.StatBase[ST_AGILITY] < 4 ){
			lexems += "$Agility @msg dlg " + DLGSTR( BankerDialog, DlgStr + 31 ) + "@";
		} else if ( cr.StatBase[ST_AGILITY] >= 4 && cr.StatBase[ST_AGILITY] < 7 ){
			lexems += "$Agility" + "";
		} else if ( cr.StatBase[ST_AGILITY] >= 7 && cr.StatBase[ST_AGILITY] <= 8 ){
			lexems += "$Agility @msg dlg " + DLGSTR( BankerDialog, DlgStr + 32 ) + "@";
		} else {
			lexems += "$Agility @msg dlg " + DLGSTR( BankerDialog, DlgStr + 33 ) + "@";
		}
		// Удача.
		if ( cr.StatBase[ST_LUCK] < 4 ){
			lexems += "$Luck @msg dlg " + DLGSTR( BankerDialog, DlgStr + 34 ) + "@";
		} else if ( cr.StatBase[ST_LUCK] >= 4 && cr.StatBase[ST_LUCK] < 7 ){
			lexems += "$Luck" + "";
		} else if ( cr.StatBase[ST_LUCK] >= 7 && cr.StatBase[ST_LUCK] <= 8 ){
			lexems += "$Luck @msg dlg " + DLGSTR( BankerDialog, DlgStr + 35 ) + "@";
		} else {
			lexems += "$Luck @msg dlg " + DLGSTR( BankerDialog, DlgStr + 36 ) + "@";
		}
		player.SayMsg( SAY_APPEND, TEXTMSG_DLG, DLGSTR( BankerDialog, DlgStr + 3 ), lexems );
	}

	// Тагнутые боевые навыки.
	if ( player.Skill[SK_SPEECH] >= 80 - ( player.Stat[ST_CHARISMA] + player.Stat[ST_LUCK] )/2 ) {

		uint[] CombatSkills = { SK_SMALL_GUNS, SK_BIG_GUNS, SK_ENERGY_WEAPONS, SK_UNARMED, SK_THROWING };
		uint[] TagSkills = { cr.TagSkill[TAG_SKILL1], cr.TagSkill[TAG_SKILL2], cr.TagSkill[TAG_SKILL3], cr.TagSkill[TAG_SKILL4] };

		for( uint i=0; i<CombatSkills.length(); i++ ){
			for( uint t=0; t<TagSkills.length(); t++ ){
				if ( CombatSkills[i] == TagSkills[t] ){
					if ( cr.Skill[TagSkills[t]] < 100 ){
						lexems = "$CmbtSkillTag @msg dlg " + DLGSTR( BankerDialog, DlgStr + 60 + Random(0,1) ) + "@";
						switch( TagSkills[t] ){
							case SK_SMALL_GUNS:		lexems += "$CombatSkillMax @msg dlg " + DLGSTR( BankerDialog, DlgStr + 41 ) + "@"; break;
							case SK_BIG_GUNS:		lexems += "$CombatSkillMax @msg dlg " + DLGSTR( BankerDialog, DlgStr + 42 ) + "@"; break;
							case SK_ENERGY_WEAPONS:	lexems += "$CombatSkillMax @msg dlg " + DLGSTR( BankerDialog, DlgStr + 43 ) + "@"; break;
							case SK_UNARMED:		lexems += "$CombatSkillMax @msg dlg " + DLGSTR( BankerDialog, DlgStr + 44 ) + "@"; break;
							case SK_THROWING:		lexems += "$CombatSkillMax @msg dlg " + DLGSTR( BankerDialog, DlgStr + 46 ) + "@"; break;
							default: break;
						}
						player.SayMsg( SAY_APPEND, TEXTMSG_DLG, DLGSTR( BankerDialog, DlgStr + 6 ), lexems );
					}
				}
			}
		}

	}

	// Тагнутые небоевые навыки.
	if ( player.Skill[SK_SPEECH] >= 85 - ( player.Stat[ST_CHARISMA] + player.Stat[ST_LUCK] )/2 ) {
		uint[] Skills = { SK_FIRST_AID, SK_DOCTOR, SK_SNEAK, SK_LOCKPICK, SK_STEAL, SK_TRAPS, SK_SCIENCE, SK_REPAIR, SK_SPEECH, SK_BARTER, SK_GAMBLING, SK_OUTDOORSMAN };
		uint[] TagSkills = { cr.TagSkill[TAG_SKILL1], cr.TagSkill[TAG_SKILL2], cr.TagSkill[TAG_SKILL3], cr.TagSkill[TAG_SKILL4] };
		for( uint i=0; i<Skills.length(); i++ ){
			for( uint t=0; t<TagSkills.length(); t++ ){
				if ( Skills[i] == TagSkills[t] ){
					if ( cr.Skill[TagSkills[t]] < 100 ){
						lexems = "$SkillTag @msg dlg " + DLGSTR( BankerDialog, DlgStr + 62 + Random(0,2) ) + "@";
						switch( TagSkills[t] ){
							case SK_FIRST_AID:	lexems += "$AnySkill @msg dlg " + DLGSTR( BankerDialog, DlgStr + 65 ) + "@"; break;
							case SK_DOCTOR:		lexems += "$AnySkill @msg dlg " + DLGSTR( BankerDialog, DlgStr + 66 ) + "@"; break;
							case SK_SNEAK:		lexems += "$AnySkill @msg dlg " + DLGSTR( BankerDialog, DlgStr + 67 ) + "@"; break;
							case SK_LOCKPICK:	lexems += "$AnySkill @msg dlg " + DLGSTR( BankerDialog, DlgStr + 68 ) + "@"; break;
							case SK_STEAL:		lexems += "$AnySkill @msg dlg " + DLGSTR( BankerDialog, DlgStr + 69 ) + "@"; break;
							case SK_TRAPS:		lexems += "$AnySkill @msg dlg " + DLGSTR( BankerDialog, DlgStr + 70 ) + "@"; break;
							case SK_SCIENCE:	lexems += "$AnySkill @msg dlg " + DLGSTR( BankerDialog, DlgStr + 71 ) + "@"; break;
							case SK_REPAIR:		lexems += "$AnySkill @msg dlg " + DLGSTR( BankerDialog, DlgStr + 72 ) + "@"; break;
							case SK_SPEECH:		lexems += "$AnySkill @msg dlg " + DLGSTR( BankerDialog, DlgStr + 73 ) + "@"; break;
							case SK_BARTER:		lexems += "$AnySkill @msg dlg " + DLGSTR( BankerDialog, DlgStr + 74 ) + "@"; break;
							case SK_GAMBLING:	lexems += "$AnySkill @msg dlg " + DLGSTR( BankerDialog, DlgStr + 75 ) + "@"; break;
							case SK_OUTDOORSMAN:lexems += "$AnySkill @msg dlg " + DLGSTR( BankerDialog, DlgStr + 76 ) + "@"; break;
							default: break;
						}
						player.SayMsg( SAY_APPEND, TEXTMSG_DLG, DLGSTR( BankerDialog, DlgStr + 7 ), lexems );
					}
				}
			}
		}

	}

	// Прокачаный боевой навык.
	if ( player.Skill[SK_SPEECH] >= 90 - ( player.Stat[ST_CHARISMA] + player.Stat[ST_LUCK] )/2 ) {

		lexems = "";
		int CurSkill = 0;
		int MaxSkill = 0;
		uint[] CombatSkills = { SK_SMALL_GUNS, SK_BIG_GUNS, SK_ENERGY_WEAPONS, SK_UNARMED, SK_THROWING };

		for( uint i=0; i<CombatSkills.length(); i++ ){
			if ( CurSkill < cr.Skill[ CombatSkills[i] ] ){
				CurSkill = cr.Skill[ CombatSkills[i] ];
				MaxSkill = CombatSkills[i];
			}
		}
		if ( CurSkill < 90 ) {
			lexems += "$CombatSkillLvl @msg dlg " + DLGSTR( BankerDialog, DlgStr + 37 ) + "@";
			lexems += "$CombatSkillMax";
		} else {
			if ( CurSkill >= 90 && CurSkill < 150 ) lexems += "$CombatSkillLvl @msg dlg " + DLGSTR( BankerDialog, DlgStr + 38 ) + "@";
			if ( CurSkill >= 150 && CurSkill < 200 ) lexems += "$CombatSkillLvl @msg dlg " + DLGSTR( BankerDialog, DlgStr + 39 ) + "@";
			if ( CurSkill >= 200 ) lexems += "$CombatSkillLvl @msg dlg " + DLGSTR( BankerDialog, DlgStr + 40 ) + "@";
			switch( MaxSkill ){
				case SK_SMALL_GUNS:		lexems += "$CombatSkillMax @msg dlg " + DLGSTR( BankerDialog, DlgStr + 41 ) + "@"; break;
				case SK_BIG_GUNS:		lexems += "$CombatSkillMax @msg dlg " + DLGSTR( BankerDialog, DlgStr + 42 ) + "@"; break;
				case SK_ENERGY_WEAPONS:	lexems += "$CombatSkillMax @msg dlg " + DLGSTR( BankerDialog, DlgStr + 43 ) + "@"; break;
				case SK_UNARMED:		lexems += "$CombatSkillMax @msg dlg " + DLGSTR( BankerDialog, DlgStr + 44 ) + "@"; break;
				case SK_THROWING:		lexems += "$CombatSkillMax @msg dlg " + DLGSTR( BankerDialog, DlgStr + 46 ) + "@"; break;
				default: break;
			}
		}
		player.SayMsg( SAY_APPEND, TEXTMSG_DLG, DLGSTR( BankerDialog, DlgStr + 4 ), lexems );

	}

	// Прокачаный небоевой навык.
	if ( player.Skill[SK_SPEECH] >= 100 - ( player.Stat[ST_CHARISMA] + player.Stat[ST_LUCK] )/2 ) {

		lexems = "";
		int CurSkill = 0;
		int MaxSkill = 0;
		uint[] Skills = { SK_FIRST_AID, SK_DOCTOR, SK_SNEAK, SK_LOCKPICK, SK_STEAL, SK_TRAPS, SK_SCIENCE, SK_REPAIR, SK_SPEECH, SK_BARTER, SK_GAMBLING, SK_OUTDOORSMAN };

		for( uint i=0; i<Skills.length(); i++ ){
			if ( CurSkill < cr.Skill[ Skills[i] ] ){
				CurSkill = cr.Skill[ Skills[i] ];
				MaxSkill = Skills[i];
			}
		}
		if ( CurSkill <= 90 ) {
			lexems += "$AnySkill @msg dlg " + DLGSTR( BankerDialog, DlgStr + 47 ) + "@";
		} else {
			switch( MaxSkill ){
				case SK_FIRST_AID:	lexems += "$AnySkill @msg dlg " + DLGSTR( BankerDialog, DlgStr + 48 ) + "@"; break;
				case SK_DOCTOR:		lexems += "$AnySkill @msg dlg " + DLGSTR( BankerDialog, DlgStr + 49 ) + "@"; break;
				case SK_SNEAK:		lexems += "$AnySkill @msg dlg " + DLGSTR( BankerDialog, DlgStr + 50 ) + "@"; break;
				case SK_LOCKPICK:	lexems += "$AnySkill @msg dlg " + DLGSTR( BankerDialog, DlgStr + 51 ) + "@"; break;
				case SK_STEAL:		lexems += "$AnySkill @msg dlg " + DLGSTR( BankerDialog, DlgStr + 52 ) + "@"; break;
				case SK_TRAPS:		lexems += "$AnySkill @msg dlg " + DLGSTR( BankerDialog, DlgStr + 53 ) + "@"; break;
				case SK_SCIENCE:	lexems += "$AnySkill @msg dlg " + DLGSTR( BankerDialog, DlgStr + 54 ) + "@"; break;
				case SK_REPAIR:		lexems += "$AnySkill @msg dlg " + DLGSTR( BankerDialog, DlgStr + 55 ) + "@"; break;
				case SK_SPEECH:		lexems += "$AnySkill @msg dlg " + DLGSTR( BankerDialog, DlgStr + 56 ) + "@"; break;
				case SK_BARTER:		lexems += "$AnySkill @msg dlg " + DLGSTR( BankerDialog, DlgStr + 57 ) + "@"; break;
				case SK_GAMBLING:	lexems += "$AnySkill @msg dlg " + DLGSTR( BankerDialog, DlgStr + 58 ) + "@"; break;
				case SK_OUTDOORSMAN:lexems += "$AnySkill @msg dlg " + DLGSTR( BankerDialog, DlgStr + 59 ) + "@"; break;
				default: break;
			}
		}
		player.SayMsg( SAY_APPEND, TEXTMSG_DLG, DLGSTR( BankerDialog, DlgStr + 5 ), lexems );

	}

	// Количество денег на счету.
	if ( player.Skill[SK_SPEECH] >= 110 - ( player.Stat[ST_CHARISMA] + player.Stat[ST_LUCK] )/2 ) {
		lexems = "";
		lexems += "$ReplMoney " + cr.Stat[ST_REPLICATION_MONEY] + "$ReplCount " + cr.Stat[ST_REPLICATION_COUNT];
		player.SayMsg( SAY_APPEND, TEXTMSG_DLG, DLGSTR( BankerDialog, DlgStr + 8 ), lexems );
	}
}

void dlg_ForSearching( Critter& player, Critter@ barman, string@ playerName )
{
	if ( !valid(barman) ) return;
	if ( !IS_DIALOG_SAY_MODE(playerName) || IS_DIALOG_END(playerName) ) return;
	if ( playerName.length() <= 1 ) return;
	uint BankerDialog = barman.Stat[ST_DIALOG_ID];
	uint DlgStr = 200;
	// Имя запрашиваемого криттера и инициализация переменной с лексемами.
	string lexems = "$Victim " + playerName;
	// Пол бармена.
	if ( barman.Stat[ST_GENDER] == GENDER_FEMALE) {
		lexems += "$BarmanGen @msg dlg " + DLGSTR( BankerDialog, DlgStr + 10 ) + "@";
	} else {
		lexems += "$BarmanGen @msg dlg " + DLGSTR( BankerDialog, DlgStr + 9 ) + "@";
	}
	// Игрок не найден.
	Critter@ cr = GetPlayer(playerName);
	if ( !valid(cr) ) {
		player.SayMsg( SAY_DIALOG, TEXTMSG_DLG, DLGSTR( BankerDialog, DlgStr + 0 ), lexems );
		return;
	}
	// Пол запрашиваемого криттера.
	if ( cr.Stat[ST_GENDER] == GENDER_FEMALE) {
		lexems += "$Gender @msg dlg " + DLGSTR( BankerDialog, DlgStr + 8 ) + "@";
	} else {
		lexems += "$Gender @msg dlg " + DLGSTR( BankerDialog, DlgStr + 7 ) + "@";
	}
	player.SayMsg( SAY_DIALOG, TEXTMSG_DLG, DLGSTR( BankerDialog, DlgStr + 11 ), lexems );
	return;
}

void dlg_TrySearching( Critter& player, Critter@ barman, string@ playerName )
{

	#define LOC_NAME #(mapId)	 		((mapId + 100) * 1000 )// поиск названия локации в файле FOGM.msg
	if ( !valid(barman) ) return;
	if ( !IS_DIALOG_SAY_MODE(playerName) || IS_DIALOG_END(playerName) ) return;
	if ( playerName.length() <= 1 ) return;
	uint BankerDialog = barman.Stat[ST_DIALOG_ID];
	uint DlgStr = 200;
	// Имя запрашиваемого криттера и инициализация переменной с лексемами.
	string lexems = "$Victim " + playerName;
	// Пол бармена.
	if ( barman.Stat[ST_GENDER] == GENDER_FEMALE) {
		lexems += "$BarmanGen @msg dlg " + DLGSTR( BankerDialog, DlgStr + 10 ) + "@";
	} else {
		lexems += "$BarmanGen @msg dlg " + DLGSTR( BankerDialog, DlgStr + 9 ) + "@";
	}
	// Игрок не найден.
	Critter@ cr = GetPlayer(playerName);
	if ( !valid(cr) ) {
		player.SayMsg( SAY_DIALOG, TEXTMSG_DLG, DLGSTR( BankerDialog, DlgStr + 0 ), lexems );
		return;
	}
	// Пол запрашиваемого криттера.
	if ( cr.Stat[ST_GENDER] == GENDER_FEMALE) {
		lexems += "$Gender @msg dlg " + DLGSTR( BankerDialog, DlgStr + 8 ) + "@";
	} else {
		lexems += "$Gender @msg dlg " + DLGSTR( BankerDialog, DlgStr + 7 ) + "@";
	}
	// Игрок спрашивает о самом себе.
	if ( player.Id == cr.Id ){
		player.SayMsg( SAY_DIALOG, TEXTMSG_DLG, DLGSTR( BankerDialog, DlgStr + 1 ) );
		return;
	}
	// Криттер на глобале.
	Map@ map = cr.GetMap();
	if ( !valid(map) ) {
		player.SayMsg( SAY_DIALOG, TEXTMSG_DLG, DLGSTR( BankerDialog, DlgStr + 2 ), lexems );
		return;
	}
	// Локация, где находится криттер. Диапазоны PID: до 150 и 210-235. Города и репликации.
	if ( cr.GetMap().GetLocation().GetProtoId() < 50 || cr.GetMap().GetLocation().GetProtoId() >= 200 ){
		lexems += "$Place @msg GM " + LOC_NAME( cr.GetMap().GetLocation().GetProtoId() ) + "@";
		// Криттер находится в той же локации, что и игрок.
		if ( barman.GetMap().GetLocation().Id == cr.GetMap().GetLocation().Id ){
			player.SayMsg( SAY_DIALOG, TEXTMSG_DLG, DLGSTR( BankerDialog, DlgStr + 3 ), lexems );
			return;
		}
		// Криттер найден, лексемы сформированы - даем информацию.
		player.SayMsg( SAY_DIALOG, TEXTMSG_DLG, DLGSTR( BankerDialog, DlgStr + 4 + Random( 0, 2 ) ), lexems );
	} else {
		player.SayMsg( SAY_DIALOG, TEXTMSG_DLG, DLGSTR( BankerDialog, DlgStr + 2 ), lexems );
		return;
	}
}

void r_ToHeal(Critter& player, Critter@ npc)
{
	HealCritter(player);
}

void r_DropDrugs(Critter & player, Critter @ npc)
{
	DropDrugEffects(player);
}

void r_DropRadiation(Critter & player, Critter @ npc)
{
	DropRadiation(player);
}

void r_ShowLocation(Critter& player, Critter@ npc, int locNum)
{
	player.SetKnownLoc(false, uint16(locNum));
}

void r_FadeOut(Critter& player, Critter@ npc ,int time)
{
	if (time==0) time=2000;
	FlushScreen(player, false, time);
}

void r_TransitToGlobal(Critter& player, Critter@ npc)
{
	player.TransitToGlobal(false);
}

void r_TransitToLocation(Critter& player, Critter@ npc, int locPid, int mapIndex)
{
	TransitToLoc(player,locPid,mapIndex,0);
}

void r_TransitToMap(Critter& player, Critter@ npc, int mapPid, int entranceNum)
{
	TransitToMap(player,mapPid,entranceNum);
}

void r_InfoMessage(Critter& player, Critter@ npc, int strNum)
{
	InfoMessage(player,npc,strNum);
}

// Установка таймаута в часах на отдельного нпц (общий для всех игроков).
void r_TimeoutSet(Critter& player, Critter@ npc, int gameHours)
{
	if(valid(npc))
		TimeoutSet(npc,gameHours);
}

// Установка таймаута в минутах для связки игрок/нпц.
void r_SetUniqTO(Critter & player, Critter @ npc, int value)
{
	if(!valid(npc)) return;
	GameVar @ to = GetUnicumVar(UVAR_uniq_timeout, player.Id, npc.Id);
	if(!valid(to)) return;
	to = value*60+__FullSecond;
}

void r_DoorOpen(Critter& player, Critter@ npc, int entireNum)
{
	DoorControl(player,entireNum,true);
}

void r_DoorClose(Critter& player, Critter@ npc, int entireNum)
{
	DoorControl(player,entireNum,false);
}

// Даем игроку голодиск
void r_GiveHolodisk(Critter& player, Critter@ npc, int holodiskNum)
{
	Item@ holo=player.AddItem(PID_HOLODISK,1);
	holo.HolodiskNumber=holodiskNum;
	holo.Update();
}

void r_Attack(Critter& player, Critter@ npc, int npcRole)
{
	Attack(player, npcRole);
}

void r_AttackStop(Critter& player, Critter@ npc, int npcRole)
{
	AttackStop(player, npcRole);
}

void r_Kill(Critter& player, Critter@ npc, int type)
{
	Kill(player, type);
}

void r_Damage(Critter& player, Critter@ npc,int dmg, int type, int dir)
{
	Damage(player, dmg, type, dir);
}

// Атака игрока всеми НПЦ на карте, у которых команда совпадает с командой говорящего НПЦ
void r_TeamAttack(Critter& player, Critter@ npc)
{
	if(!valid(npc))
		return;
	Map@ map = npc.GetMap();
	if(!valid(map))
		return;
	Critter@[] team;
	if(map.GetCritters(0, FIND_LIFE|FIND_ONLY_NPC, team)>0)
	{
		for(uint i = 0, l = team.length(); i < l; i++)
		{
			if(team[i].Stat[ST_TEAM_ID] == npc.Stat[ST_TEAM_ID])
				AddAttackPlane(team[i], 0, player.Id,true);
		}
	}
}

// Отложенная всплывающая строка над нпц
void r_SayMessageDelayed(Critter & player, Critter @ npc, int strNum, int delaySeconds, int sayType)
{
	if(!valid(npc)) return;
	uint[] values = {npc.Id, uint(sayType), uint(strNum)};
	CreateTimeEvent(__FullSecond + delaySeconds, "e_SayMessage", values, false);
}

uint e_SayMessage(uint[]@ values)
{
	if(values.length() < 3) return 0;
	Critter @ cr = GetCritter(values[0]);
	if(!valid(cr)) return 0;
	int did = cr.Stat[ST_DIALOG_ID];
	if(did == 0) return 0;
	cr.SayMsg(values[1], TEXTMSG_DLG, DLGSTR(did, values[2]));
	return 0;
}

void r_SkillUp(Critter& player, Critter@ npc, int skill)
{
	SkillUp(player, skill);
}

void r_MakeOperationA(Critter& cr, Critter@ npc)
{
	if(cr.ParamBase[ST_SLOT_C]!=0) return;
	if(cr.CountItem(PID_BOTTLE_CAPS)>=5000 && cr.ParamBase[HONOR_POINTS]>=3000){
		cr.DeleteItem(PID_BOTTLE_CAPS,5000);
		cr.ParamBase[HONOR_POINTS]-=3000;
		cr.ParamBase[ST_SLOT_A]=1;
	}
}
void r_MakeOperationB(Critter& cr, Critter@ npc)
{
	if(cr.ParamBase[ST_SLOT_B]!=0) return;
	if(cr.CountItem(PID_BOTTLE_CAPS)>=5000 && cr.ParamBase[HONOR_POINTS]>=3000){
		cr.DeleteItem(PID_BOTTLE_CAPS,5000);
		cr.ParamBase[HONOR_POINTS]-=3000;
		cr.ParamBase[ST_SLOT_B]=1;
	}
}
void r_MakeOperationC(Critter& cr, Critter@ npc)
{
	if(cr.ParamBase[ST_SLOT_C]!=0) return;
	if(cr.CountItem(PID_BOTTLE_CAPS)>=5000 && cr.ParamBase[HONOR_POINTS]>=3000){
		cr.DeleteItem(PID_BOTTLE_CAPS,5000);
		cr.ParamBase[HONOR_POINTS]-=3000;
		cr.ParamBase[ST_SLOT_C]=1;
	}
}


void r_TeleportToMap(Critter& cr, Critter@ npc)
{
	cr.DeleteItem(PID_BOTTLE_CAPS,100);
	//London - Dark Waters
	if(cr.GetMap().GetProtoId()==711) cr.TransitToMap(GetMapByPid(702,0).Id,550);
	else if(cr.GetMap().GetProtoId()==702) cr.TransitToMap(GetMapByPid(711,0).Id,550);
	//Moscow - Town Station
	else if(cr.GetMap().GetProtoId()==699) cr.TransitToMap(GetMapByPid(668,0).Id,550);
	else if(cr.GetMap().GetProtoId()==668) cr.TransitToMap(GetMapByPid(699,0).Id,550);
}

void r_TeleportToMap2(Critter& cr, Critter@ npc)
{
	cr.DeleteItem(PID_BOTTLE_CAPS,200);
	//Scrapers - Dark Waters
	if(cr.GetMap().GetProtoId()==694) cr.TransitToMap(GetMapByPid(702,0).Id,560);
	else if(cr.GetMap().GetProtoId()==702) cr.TransitToMap(GetMapByPid(694,0).Id,560);
}


void r_TeleportIsland(Critter& cr, Critter@ npc)
{
	if(cr.CountItem(PID_WOOD)<13 && cr.CountItem(PID_DE_PRIMITIVE_TOOL)==0) 
	{
		cr.AddItem(PID_DE_PRIMITIVE_TOOL,1);
		npc.SayMsg(SAY_NORM_ON_HEAD, TEXTMSG_GAME, 3000001000);
	}
	else if(cr.CountItem(PID_WOOD)>=13)
	{
		cr.DeleteItem(PID_WOOD,13);
		cr.DeleteItem(PID_DE_PRIMITIVE_TOOL,10);
		cr.ParamBase[PLAYER_IS_BANNED]=1;
		if(cr.GetMap().GetProtoId()==700) cr.TransitToMap(GetMapByPid(886,0).Id,0);
	}

}


void r_ResetReputationBLUE(Critter& cr, Critter@ npc)
{
	if(cr.CountItem(PID_BOTTLE_CAPS)>=4000)
	{
		cr.DeleteItem(PID_BOTTLE_CAPS,4000);
		cr.ParamBase[REPUTATION_BLUE]=0;
	}
}

void r_ResetReputationRED(Critter& cr, Critter@ npc)
{
	if(cr.CountItem(PID_BOTTLE_CAPS)>=4000)
	{
		cr.DeleteItem(PID_BOTTLE_CAPS,4000);
		cr.ParamBase[REPUTATION_RED]=0;
	}
}

void r_SetRED(Critter& cr, Critter@ npc)
{
	if(cr.CountItem(PID_BOTTLE_CAPS)>=3000)
	{
		cr.DeleteItem(PID_BOTTLE_CAPS,3000);
		cr.ParamBase[PLAYER_MAIN_FACTION]=1;
	}
}

void r_SetBLUE(Critter& cr, Critter@ npc)
{
	if(cr.CountItem(PID_BOTTLE_CAPS)>=3000)
	{
		cr.DeleteItem(PID_BOTTLE_CAPS,3000);
		cr.ParamBase[PLAYER_MAIN_FACTION]=2;
	}
}
// Automatic Regeneration Medical Robot "Medical-Tec"
bool s_MedicalRobot_REF(Critter&player,Scenery&terminal,int skill,Item@item)
{
	if(player.IsPlayer()&&skill==-1&&not(@item!=null))RunDialog(player,21027,terminal.HexX,terminal.HexY,false);
	return true;
}

bool s_MedicalRobot_NEC(Critter&player,Scenery&terminal,int skill,Item@item)
{
	if(player.IsPlayer()&&skill==-1&&not(@item!=null))RunDialog(player,21028,terminal.HexX,terminal.HexY,false);
	return true;
}

void r_MedicalRobot(Critter& cr, Critter@ npc)
{
	cr.StatBase[ST_CURRENT_HP]=cr.Stat[ST_MAX_LIFE];
	cr.DamageBase[DAMAGE_POISONED]=0;
	cr.DamageBase[DAMAGE_RADIATED]=0;		
	cr.DamageBase[DAMAGE_LEFT_LEG]=0;
	cr.DamageBase[DAMAGE_RIGHT_LEG]=0;
	cr.DamageBase[DAMAGE_LEFT_ARM]=0;
	cr.DamageBase[DAMAGE_RIGHT_ARM]=0;
	cr.DamageBase[DAMAGE_EYE]=0;
	cr.RunClientScript("_FlushScreen",int(0xFFFFFFFF),0,int(10000),null,null);
	cr.PlaySound("EKG03.ogg",true);
}

// MEDICAL ROBOT FOR BUNKER BASE
bool s_MedicalRobotUse(Critter&player,Scenery&terminal,int skill,Item@item)
{
	if(player.IsPlayer()&&skill==-1&&not(@item!=null))
	{
		if(__FullSecond<uint(player.ParamBase[TO_SK_DOCTOR]) || __FullSecond<uint(player.ParamBase[TO_SK_SCIENCE]))
			{
			player.SayMsg(SAY_NETMSG,TEXTMSG_GAME,212);
			}
	
		else if(player.CountItem(PID_SMALL_ENERGY_CELL_DE)>=25 && player.CountItem(PID_BIO_GEL)>=1)
	
			{
			player.DeleteItem(PID_SMALL_ENERGY_CELL_DE,25);
			player.DeleteItem(PID_BIO_GEL,1);
			player.StatBase[ST_CURRENT_HP]=player.Stat[ST_MAX_LIFE];
			player.DamageBase[DAMAGE_POISONED]=0;
			player.DamageBase[DAMAGE_RADIATED]=0;		
			player.DamageBase[DAMAGE_LEFT_LEG]=0;
			player.DamageBase[DAMAGE_RIGHT_LEG]=0;
			player.DamageBase[DAMAGE_LEFT_ARM]=0;
			player.DamageBase[DAMAGE_RIGHT_ARM]=0;
			player.DamageBase[DAMAGE_EYE]=0;
			player.RunClientScript("_FlushScreen",int(0xFFFFFFFF),0,int(10000),null,null);
			player.PlaySound("EKG03.ogg",true);
			player.TimeoutBase[TO_SK_DOCTOR]=int(__FullSecond+REAL_MINUTE(5));
			player.TimeoutBase[TO_SK_SCIENCE]=int(__FullSecond+REAL_MINUTE(5));
			player.SayMsg(SAY_NETMSG,TEXTMSG_GAME,3000001040);
			}
		else
			{
			player.RunClientScript("_FlushScreen",int(0xFF00000),0,int(1000),null,null);
			player.Say(SAY_NORM_ON_HEAD,"Hmmmm...");
			player.PlaySound("accessdenied01.ogg",true);
			player.SayMsg(SAY_NETMSG,TEXTMSG_GAME,3000001050);
			}
	}
	return true;
}

/*
// COOKING FOOD FROM STOVE
bool s_CookingFood(Critter&player,Scenery&terminal,int skill,Item@item)
{
	if(player.IsPlayer()&&skill==-1&&not(@item!=null))
	{
		if(player.CountItem(PID_MEAT)>=1 && player.CountItem(PID_WOOD)>=1)
			{
			player.DeleteItem(PID_MEAT,1);
			player.DeleteItem(PID_WOOD,1);
			player.AddItem(PID_COOKED_MEAT,1);
			}
		else
			{
			player.SayMsg(SAY_NETMSG,TEXTMSG_GAME,212);
			}
		}
	return true;
}
*/


// ACCESS DENIED SOUND WITH HIT
void r_AccessDenied(Critter& cr, Critter@ npc)
{
	cr.StatBase[ST_CURRENT_HP]-=5;
	cr.RunClientScript("_FlushScreen",int(0xFF00000),0,int(1000),null,null);
	cr.Say(SAY_NORM_ON_HEAD,"Auuuu");
	cr.PlaySound("accessdenied01.ogg",true);
}
// SOUND FOR ANIMAL "no talk"
void r_AnimalBrahminSound(Critter& cr, Critter@ npc)
{
	npc.SayMsg(SAY_NORM_ON_HEAD, TEXTMSG_GAME, 3000001000);
	cr.PlaySound("cow02.ogg",true);
}

void r_AnimalDogSound(Critter& cr, Critter@ npc)
{
	npc.SayMsg(SAY_NORM_ON_HEAD, TEXTMSG_GAME, 3000001000);
	cr.PlaySound("MADDOGGR.acm",true);
}

// DEV TERMINAL
bool s_DevTerminal(Critter&player,Scenery&terminal,int skill,Item@item)
{
	if(player.IsPlayer()&&skill==-1&&not(@item!=null))RunDialog(player,21029,terminal.HexX,terminal.HexY,false);
	return true;
}
void r_DevTerminal1(Critter& cr, Critter@ npc)
{
	cr.PlaySound("accessdenied01.ogg",true);
}
void r_DevTerminal2(Critter& cr, Critter@ npc)
{
	cr.RunClientScript("_FlushScreen",int(0xFF00FF00),0,int(1000),null,null);
	cr.Say(SAY_NORM_ON_HEAD,":)");
	cr.PlaySound("LEVELUP.ACM",true);
}
void r_UnlockSlotHead(Critter& cr, Critter@ npc)
{
	cr.ParamBase[ST_SLOT_HEAD]=1;
	cr.RunClientScript("_FlushScreen",int(0xFF000000),0,int(1000),null,null);
	//cr.Say(SAY_NORM_ON_HEAD,"thx");
}

// LONDON UNDERGROUND TELEPORT DOOR TERMINAL
bool s_LondonTerminal(Critter&player,Scenery&terminal,int skill,Item@item)
{
	if(player.IsPlayer()&&skill==-1&&not(@item!=null))RunDialog(player,21030,terminal.HexX,terminal.HexY,false);
	return true;
}

// HONOR POINTS TERMINAL
bool s_HonorTerminal(Critter&player,Scenery&terminal,int skill,Item@item)
{
	if(player.IsPlayer()&&skill==-1&&not(@item!=null))RunDialog(player,21032,terminal.HexX,terminal.HexY,false);
	return true;
}

// SCRAPERS TEC-TOWER ELEVATOR DIALOG
bool s_ScrapersElevator(Critter&player,Scenery&terminal,int skill,Item@item)
{
	if(player.IsPlayer()&&skill==-1&&not(@item!=null))RunDialog(player,21031,terminal.HexX,terminal.HexY,false);
	return true;
}

// ACCESS DENIED SOUND
void r_accessdenied(Critter& cr, Critter@ npc)
{
	cr.PlaySound("accessdenied01.ogg",true);
}

// BUYING BASE
uint r_ClayHouse1(Critter& cr, Critter@ npc)
{
	if(cr.CountItem(PID_BOTTLE_CAPS)>=7500)
	{
		cr.DeleteItem(PID_BOTTLE_CAPS,7500);
		cr.AddItem(PID_PLAN7,1);
		return FD_MONEY_FOR_BASE;
	}
	else return FD_NO_MONEY_FOR_BASE;
}

uint r_Cave1(Critter& cr, Critter@ npc)

{
	if(cr.CountItem(PID_BOTTLE_CAPS)>=10000)
	{
		cr.DeleteItem(PID_BOTTLE_CAPS,10000);
		cr.AddItem(PID_PLAN1,1);
		return FD_MONEY_FOR_BASE;
	}
	else return FD_NO_MONEY_FOR_BASE;
}

uint r_Tent1(Critter& cr, Critter@ npc)
{
	if(cr.CountItem(PID_BOTTLE_CAPS)>=10000)
	{
		cr.DeleteItem(PID_BOTTLE_CAPS,10000);
		cr.AddItem(PID_PLAN3,1);
		return FD_MONEY_FOR_BASE;
	}
	else return FD_NO_MONEY_FOR_BASE;
}

uint r_BrickHouse1(Critter& cr, Critter@ npc)
{
	if(cr.CountItem(PID_BOTTLE_CAPS)>=10000)
	{
		cr.DeleteItem(PID_BOTTLE_CAPS,10000);
		cr.AddItem(PID_PLAN4,1);
		return FD_MONEY_FOR_BASE;
	}
	else return FD_NO_MONEY_FOR_BASE;
}

uint r_Ranch1(Critter& cr, Critter@ npc)
{
	if(cr.CountItem(PID_BOTTLE_CAPS)>=12500)
	{
		cr.DeleteItem(PID_BOTTLE_CAPS,12500);
		cr.AddItem(PID_PLAN6,1);
		return FD_MONEY_FOR_BASE;
	}
	else return FD_NO_MONEY_FOR_BASE;
}

uint r_GasStation1(Critter& cr, Critter@ npc)
{
	if(cr.CountItem(PID_BOTTLE_CAPS)>=13500)
	{
		cr.DeleteItem(PID_BOTTLE_CAPS,13500);
		cr.AddItem(PID_PLAN5,1);
		return FD_MONEY_FOR_BASE;
	}
	else return FD_NO_MONEY_FOR_BASE;
}

uint r_Bunker1(Critter& cr, Critter@ npc)
{
	if(cr.CountItem(PID_BOTTLE_CAPS)>=50000)
	{
		cr.DeleteItem(PID_BOTTLE_CAPS,50000);
		cr.AddItem(PID_PLAN2,1);
		return FD_MONEY_FOR_BASE;
	}
	else return FD_NO_MONEY_FOR_BASE;
}

bool PickAxeTimeoutIs(Critter& cr, Critter@ npc, int val)
{
	if(uint(cr.ParamBase[PICKAXE_TIMEOUT])<__FullSecond && val==2) return true;
	else if(uint(cr.ParamBase[PICKAXE_TIMEOUT])>__FullSecond && val!=2) return true;
	else return false;
}

void setPickAxeTimeout(Critter& cr, Critter@ npc)
{
	cr.ParamBase[PICKAXE_TIMEOUT]+=__FullSecond+REAL_MINUTE(20);
}

// LEAVE or GO TO "PRISON HUNTERS CAMP"
void r_LeavePrisonHunters(Critter& cr, Critter@ npc)
{
	if((cr.CountItem(PID_WOOD)<4 && cr.CountItem(PID_IRON_ORE)<5) && (cr.ParamBase[PLAYER_IN_JAIL]==1))
	{
		npc.SayMsg(SAY_NORM_ON_HEAD, TEXTMSG_GAME, 3000001060);
	}
	if(cr.CountItem(PID_WOOD)>=4 || cr.CountItem(PID_IRON_ORE)>=5) 
	{
		ClearItems(cr);
		cr.ParamBase[PLAYER_IN_JAIL]=0;
		cr.ParamBase[ST_KARMA]+=10;
		cr.TransitToMap(GetMapByPid(752,0).Id,203);
	}
	if(cr.ParamBase[PLAYER_IN_JAIL]==0)
	{
		cr.TransitToMap(GetMapByPid(752,0).Id,203);
	}
}
void r_GoToPrisonHunters(Critter& cr, Critter@ npc)
{
	ClearItems(cr);
	cr.TransitToMap(GetMapByPid(752,0).Id,201);
	cr.AddItem(PID_ENERGY_BARIER_ACCESS_CARD,1);
}
void r_GoToPrisonHunters2(Critter& cr, Critter@ npc)
{
	ClearItems(cr);
	cr.TransitToMap(GetMapByPid(752,0).Id,201);
	cr.ToKnockout(KNOCKOUT_ANIM2_DEFAULT(true),5,cr.HexX,cr.HexY);
	//RunDialog(cr, 40037, 0,0, true);
	//Critter@[] crs;
	//RunDialog (Critter& player, uint16 dialogId, uint16 hexX, uint16 hexY, bool ignoreDistance)
	//if(map.GetCritters(NPC_GUARD_IN_JAIL,FIND_LIFE_AND_KO|FIND_ONLY_NPC,crs)>0) RunDialog(player,crs[0],true);
}

// OLD FIELDS GORDON JOB
void r_fibers_tabaco(Critter& cr, Critter@ npc)
{
	uint fibers=cr.CountItem(PID_DE_FIBER);
	uint tabaco=cr.CountItem(PID_TOBACCO);
	if(fibers+tabaco<=0) 
	{
		npc.Say(SAY_NORM_ON_HEAD,"Don't waste my time.");
		return;
	}
	uint caps=(fibers*7)+(tabaco*10);
	npc.Say(SAY_NORM_ON_HEAD,"It's your salary.");
	cr.DeleteItem(PID_DE_FIBER,fibers);
	cr.DeleteItem(PID_TOBACCO,tabaco);
	cr.AddItem(PID_BOTTLE_CAPS,caps);
}
void r_ToPlantationF(Critter& cr, Critter@ npc)
{
	cr.TransitToMap(GetMapByPid(685,0).Id,201);
}
void r_FromPlantationF(Critter& cr, Critter@ npc)
{
	cr.TransitToMap(GetMapByPid(685,0).Id,202);
}
void r_ToPlantationT(Critter& cr, Critter@ npc)
{
	cr.TransitToMap(GetMapByPid(685,0).Id,203);
}
void r_FromPlantationT(Critter& cr, Critter@ npc)
{
	cr.TransitToMap(GetMapByPid(685,0).Id,204);
}
// FOOD FOR KARMA
void r_Food_For_Karma(Critter& cr, Critter@ npc)
{
	uint noodles=cr.CountItem(PID_BOX_OF_NOODLES);
	uint iguana=cr.CountItem(PID_IGUANA_ON_A_STICK);
	uint meatstick=cr.CountItem(PID_MEAT_ON_A_STICK);
	uint meatjerky=cr.CountItem(PID_MEAT_JERKY);
	uint cookedmeat=cr.CountItem(PID_COOKED_MEAT);
	if(noodles+iguana+meatstick+meatjerky+cookedmeat<=0) 
	{
		npc.Say(SAY_NORM_ON_HEAD,"Why do you lie me...");
		return;
	}
	uint addkarma=(noodles*1)+(iguana*1)+(meatstick*1)+(meatjerky*1)+(cookedmeat*1);
	//npc.Say(SAY_NORM_ON_HEAD,"Thank you on behalf of the needy.");
	cr.DeleteItem(PID_BOX_OF_NOODLES,noodles);
	cr.DeleteItem(PID_IGUANA_ON_A_STICK,iguana);
	cr.DeleteItem(PID_MEAT_ON_A_STICK,meatstick);
	cr.DeleteItem(PID_MEAT_JERKY,meatjerky);
	cr.DeleteItem(PID_COOKED_MEAT,cookedmeat);
	//cr.StatBase(ST_KARMA,addkarma);
	cr.StatBase[ST_KARMA]+=addkarma;
}

// QUEST FLASH SCREEN
void r_FlashEffect(Critter& cr, Critter@ npc)
{
	cr.RunClientScript("_FlushScreen",int(0x00000000),0,int(10000),null,null);
	//cr.PlaySound("EKG03.ogg",true);
	//cr.Say(SAY_NORM_ON_HEAD,"Hmmmm...");
}

// GALACHAD TRADER
void r_NpcGalachadTrader(Critter& cr, Critter@ npc)
{
	GameVar @item_pid=GetLocalVar(LVAR_pid_item_galachad_trade,cr.Id);
	uint cena=NpcGalachadTraderCostItem(item_pid.GetValue());
	if(cena>cr.CountItem(PID_BOTTLE_CAPS)) return;
	switch(item_pid.GetValue())
	{
		case PID_PA:
			cr.AddItem(PID_PA,1);
			cr.DeleteItem(PID_BOTTLE_CAPS,cena);
			break;
		case PID_PAMKII:
			cr.AddItem(PID_PAMKII,1);
			cr.DeleteItem(PID_BOTTLE_CAPS,cena);
			break;
		case PID_APA: 
			cr.AddItem(PID_APA,1);
			cr.DeleteItem(PID_BOTTLE_CAPS,cena);
			break;
		case PID_MECHSUITG1:
		case PID_MECHSUITG2:
		case PID_MECHSUITB1:
		case PID_MECHSUITB2:
			cr.AddItem(item_pid.GetValue(),1);
			cr.DeleteItem(PID_BOTTLE_CAPS,cena);
			break;
		case PID_DRAGUNOV1_DE:
			cr.AddItem(PID_DRAGUNOV1_DE,1);
			cr.AddItem(PID_762X54_DE,60);
			cr.AddItem(PID_762X54G_DE,30);
			cr.DeleteItem(PID_BOTTLE_CAPS,cena);
			break;
		case PID_DRAGUNOV2_DE:
			cr.AddItem(PID_DRAGUNOV2_DE,1);
			cr.AddItem(PID_762X54_DE,60);
			cr.AddItem(PID_762X54G_DE,30);
			cr.DeleteItem(PID_BOTTLE_CAPS,cena);
			break;
		case PID_BOZAR_DE:
			cr.AddItem(PID_BOZAR_DE,1);
			cr.DeleteItem(PID_BOTTLE_CAPS,cena);
			break;
		case PID_PK12_GAUSS_PISTOL_DE:
			cr.AddItem(PID_PK12_GAUSS_PISTOL_DE,1);
			cr.AddItem(PID_2MM_EC_AMMO_DE,40);
			cr.DeleteItem(PID_BOTTLE_CAPS,cena);
			break;
		case PID_VINDICATOR_MINIGUN_DE:
			cr.AddItem(PID_VINDICATOR_MINIGUN_DE,1);
			cr.AddItem(PID_4_7MM_CASELESS_DE,100);
			cr.DeleteItem(PID_BOTTLE_CAPS,cena);
			break;
		case PID_GATLING_LASER_DE:
			cr.AddItem(PID_GATLING_LASER_DE,1);
			cr.DeleteItem(PID_BOTTLE_CAPS,cena);
			break;
		case PID_ELEPHANT_GUN_DE:
			cr.AddItem(PID_ELEPHANT_GUN_DE,1);
			cr.AddItem(PID_700_NITRO_EXPRESS_DE,100);
			cr.DeleteItem(PID_BOTTLE_CAPS,cena);
			break;
	}
}

uint NpcGalachadTraderCostItem(int pid)
{
	uint cost;
	switch(pid)
	{
		case PID_PA:
			cost = 70000 + (3000*WorldItemCount(pid));
			break;
		case PID_PAMKII:
			cost = 90000 + (4000*WorldItemCount(pid));
			break;
		case PID_APA: 
			cost = 100000 + (5000*WorldItemCount(pid));
			break;
		case PID_MECHSUITG1:
		case PID_MECHSUITG2:
		case PID_MECHSUITB1:
		case PID_MECHSUITB2:
			cost = 145000 + (Random(900,1000)*(WorldItemCount(PID_MECHSUITG1)+WorldItemCount(PID_MECHSUITG2)+WorldItemCount(PID_MECHSUITB1)+WorldItemCount(PID_MECHSUITB2)));
			break;
		case PID_DRAGUNOV1_DE:
			cost = 80000 + (Random(50,100)*WorldItemCount(pid));
			break;
		case PID_DRAGUNOV2_DE:
			cost = 125000 + (Random(50,100)*WorldItemCount(pid));
			break;
		case PID_BOZAR_DE:
			cost = 180000 + (Random(50,100)*WorldItemCount(pid));
			break;
		case PID_PK12_GAUSS_PISTOL_DE:
			cost = 125000 + (Random(50,100)*WorldItemCount(pid));
			break;
		case PID_VINDICATOR_MINIGUN_DE:
			cost = 125000 + (Random(50,100)*WorldItemCount(pid));
			break;
		case PID_GATLING_LASER_DE:
			cost = 125000 + (Random(50,100)*WorldItemCount(pid));
			break;
		case PID_ELEPHANT_GUN_DE:
			cost = 155000 + (Random(50,100)*WorldItemCount(pid));
			break;
	}
	return cost;
}

bool d_NpcGalachadTrader(Critter& cr, Critter@ npc)
{
	GameVar @item_pid=GetLocalVar(LVAR_pid_item_galachad_trade,cr.Id);
	uint cena=NpcGalachadTraderCostItem(item_pid.GetValue());
	if(cena>cr.CountItem(PID_BOTTLE_CAPS)) return false;
	return true;
}

bool d_NpcGalachadTraderDontHaveMoney(Critter& cr, Critter@ npc)
{
	return !d_NpcGalachadTrader(cr,npc);
}

void NpcGalachadTraderLex( Critter& cr, Critter@ npc, string@ lexems )
{
    if( not IS_DIALOG_GENERATED( lexems ) )
        return;
	
	GameVar @item_pid=GetLocalVar(LVAR_pid_item_galachad_trade,cr.Id);
    lexems += "$price" + NpcGalachadTraderCostItem(item_pid.GetValue());
	
}
/*
// "RUM FROM STILL_B (something does not work)"
void s_RumFromStillb(Item& item, bool firstTime)
{
	item.SetEvent(ITEM_EVENT_USE ,"s_RumFromStillbUsedOn");  /// register use event
}

bool s_RumFromStillbUsedOn(Item& item, Critter& player, Critter@ oncritter, Item@ onItem, Scenery@ onScenery)
{
	if(player.IsPlayer()&& onItem.GetProtoId()==PID_STILL_B_ACTIVE )
	{
		if(player.CountItem(PID_DE_FRUIT_2)>=3)
		{
			player.DeleteItem(PID_DE_FRUIT_2,3);
			player.AddItem(PID_ROENTGEN_RUM,1);
		}
		else
		{
			player.SayMsg(SAY_NETMSG,TEXTMSG_GAME,212);
		}
	}
	return true;
}
*/

// MONEY FOR BOOKS FROM MR. COVER
void r_booksjunk(Critter& cr, Critter@ npc)
{
	uint booksjunk=cr.CountItem(PID_BOOKJUNK);
	if(booksjunk<=0) 
	{
		npc.Say(SAY_NORM_ON_HEAD,"Don't waste my time.");
		return;
	}
	uint caps=(booksjunk*50);
	npc.Say(SAY_NORM_ON_HEAD,"It's your salary.");
	cr.DeleteItem(PID_BOOKJUNK,booksjunk);
	cr.AddItem(PID_BOTTLE_CAPS,caps);
}

// SHOOTING RANGE TELEPORT
void r_GoToShootingRange(Critter& cr, Critter@ npc)
{
	ClearItems(cr);
	cr.TransitToMap(GetMapByPid(729,0).Id,10);
	cr.ParamBase[PE_STRONG_BACK]+=30;
}

void r_ExitFromShootingRange(Critter& cr, Scenery& scen, bool cps, uint8 dir)
{
	ClearItems(cr);
	cr.TransitToMap(GetMapByPid(689,0).Id,10);
	cr.ParamBase[PE_STRONG_BACK]-=30;
}


// MEDICAL POINT
bool medical_point(Critter&player,Scenery&terminal,int skill,Item@item)
{
	if(player.IsPlayer()&&skill==-1&&not(@item!=null))
	{
		player.StatBase[ST_CURRENT_HP]=player.Stat[ST_MAX_LIFE];
		player.DamageBase[DAMAGE_POISONED]=0;
		player.DamageBase[DAMAGE_RADIATED]=0;		
		player.DamageBase[DAMAGE_LEFT_LEG]=0;
		player.DamageBase[DAMAGE_RIGHT_LEG]=0;
		player.DamageBase[DAMAGE_LEFT_ARM]=0;
		player.DamageBase[DAMAGE_RIGHT_ARM]=0;
		player.DamageBase[DAMAGE_EYE]=0;
		player.RunClientScript("_FlushScreen",int(0xFFFFFFFF),0,int(500),null,null);
		player.PlaySound("stimpack01.ogg",true);
		player.SayMsg(SAY_NETMSG,TEXTMSG_GAME,3000001040);
	}
	return true;
}

// SHOTING RANGE STOREMAN DIALOG
bool s_Storeman(Critter&player,Scenery&terminal,int skill,Item@item)
{
	if(player.IsPlayer()&&skill==-1&&not(@item!=null))RunDialog(player,40041,terminal.HexX,terminal.HexY,false);
	return true;
}

// DIALOG SOUND
void dialog_sound1(Critter& cr, Critter@ npc)
{
	cr.RunClientScript("_FlushScreen",int(0xFF000000),0,int(500),null,null);
	//cr.PlaySound("beep01.ogg",true);
	//cr.PlaySound("TANKS.ACM",true);
}